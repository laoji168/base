# log包

package log

import "log"

log包实现了简单的日志服务。本包定义了Logger类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准”Logger，可以通过辅助函数Print[f|ln]、Fatal[f|ln]和Panic[f|ln]访问，比手工创建一个Logger对象更容易使用。Logger会打印每条日志信息的日期、时间，默认输出到标准错误。Fatal系列函数会在写入日志信息后调用os.Exit(1)。Panic系列函数会在写入日志信息后panic。

### Constants

```go
const (
    // 字位共同控制输出日志信息的细节。不能控制输出的顺序和格式。
    // 在所有项目后会有一个冒号：2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    Ldate         = 1 << iota     // 日期：2009/01/23
    Ltime                         // 时间：01:23:23
    Lmicroseconds                 // 微秒分辨率：01:23:23.123123（用于增强Ltime位）
    Llongfile                     // 文件全路径名+行号： /a/b/c/d.go:23
    Lshortfile                    // 文件无路径名+行号：d.go:23（会覆盖掉Llongfile）
    LstdFlags     = Ldate | Ltime // 标准logger的初始值
)
```

这些选项定义Logger类型如何生成用于每条日志的前缀文本。

### type [Logger](https://github.com/golang/go/blob/master/src/log/log.go?name=release#42)

```go
type Logger struct {
    // contains filtered or unexported fields
}
```

Logger类型表示一个活动状态的记录日志的对象，它会生成一行行的输出写入一个io.Writer接口。每一条日志操作会调用一次io.Writer接口的Write方法。Logger类型的对象可以被多个线程安全的同时使用，它会保证对io.Writer接口的顺序访问。

Example

```go
var buf bytes.Buffer
logger := log.New(&buf, "logger: ", log.Lshortfile)
logger.Print("Hello, log file!")
fmt.Print(&buf)
```

Output:

```go
logger: example_test.go:16: Hello, log file!
```

#### func [New](https://github.com/golang/go/blob/master/src/log/log.go?name=release#54)

```go
func New(out io.Writer, prefix string, flag int) *Logger
```

New创建一个Logger。参数out设置日志信息写入的目的地。参数prefix会添加到生成的每一条日志前面。参数flag定义日志的属性（时间、文件等等）。

#### func (*Logger) [Flags](https://github.com/golang/go/blob/master/src/log/log.go?name=release#211)

```go
func (l *Logger) Flags() int
```

Flags返回logger的输出选项。

#### func (*Logger) [SetFlags](https://github.com/golang/go/blob/master/src/log/log.go?name=release#218)

```go
func (l *Logger) SetFlags(flag int)
```

SetFlags设置logger的输出选项。

#### func (*Logger) [Prefix](https://github.com/golang/go/blob/master/src/log/log.go?name=release#225)

```go
func (l *Logger) Prefix() string
```

Prefix返回logger的输出前缀。

#### func (*Logger) [SetPrefix](https://github.com/golang/go/blob/master/src/log/log.go?name=release#232)

```go
func (l *Logger) SetPrefix(prefix string)
```

SSetPrefix设置logger的输出前缀。

#### func (*Logger) [Output](https://github.com/golang/go/blob/master/src/log/log.go?name=release#130)

```go
func (l *Logger) Output(calldepth int, s string) error
```

Output写入输出一次日志事件。参数s包含在Logger根据选项生成的前缀之后要打印的文本。如果s末尾没有换行会添加换行符。calldepth用于恢复PC，出于一般性而提供，但目前在所有预定义的路径上它的值都为2。

#### func (*Logger) [Printf](https://github.com/golang/go/blob/master/src/log/log.go?name=release#159)

```go
func (l *Logger) Printf(format string, v ...interface{})
```

Printf调用l.Output将生成的格式化字符串输出到logger，参数用和fmt.Printf相同的方法处理。

#### func (*Logger) [Print](https://github.com/golang/go/blob/master/src/log/log.go?name=release#165)

```go
func (l *Logger) Print(v ...interface{})
```

Print调用l.Output将生成的格式化字符串输出到logger，参数用和fmt.Print相同的方法处理。

#### func (*Logger) [Println](https://github.com/golang/go/blob/master/src/log/log.go?name=release#169)

```go
func (l *Logger) Println(v ...interface{})
```

Println调用l.Output将生成的格式化字符串输出到logger，参数用和fmt.Println相同的方法处理。

#### func (*Logger) [Fatalf](https://github.com/golang/go/blob/master/src/log/log.go?name=release#178)

```go
func (l *Logger) Fatalf(format string, v ...interface{})
```

Fatalf等价于{l.Printf(v...); os.Exit(1)}

#### func (*Logger) [Fatal](https://github.com/golang/go/blob/master/src/log/log.go?name=release#172)

```go
func (l *Logger) Fatal(v ...interface{})
```

Fatal等价于{l.Print(v...); os.Exit(1)}

#### func (*Logger) [Fatalln](https://github.com/golang/go/blob/master/src/log/log.go?name=release#184)

```go
func (l *Logger) Fatalln(v ...interface{})
```

Fatalln等价于{l.Println(v...); os.Exit(1)}

#### func (*Logger) [Panicf](https://github.com/golang/go/blob/master/src/log/log.go?name=release#197)

```go
func (l *Logger) Panicf(format string, v ...interface{})
```

Panicf等价于{l.Printf(v...); panic(...)}

#### func (*Logger) [Panic](https://github.com/golang/go/blob/master/src/log/log.go?name=release#190)

```go
func (l *Logger) Panic(v ...interface{})
```

Panic等价于{l.Print(v...); panic(...)}

#### func (*Logger) [Panicln](https://github.com/golang/go/blob/master/src/log/log.go?name=release#204)

```go
func (l *Logger) Panicln(v ...interface{})
```

Panicln等价于{l.Println(v...); panic(...)}

### func [Flags](https://github.com/golang/go/blob/master/src/log/log.go?name=release#246)

```go
func Flags() int
```

Flags返回标准logger的输出选项。

### func [SetFlags](https://github.com/golang/go/blob/master/src/log/log.go?name=release#251)

```go
func SetFlags(flag int)
```

SetFlags设置标准logger的输出选项。

### func [Prefix](https://github.com/golang/go/blob/master/src/log/log.go?name=release#256)

```go
func Prefix() string
```

Prefix返回标准logger的输出前缀。

### func [SetPrefix](https://github.com/golang/go/blob/master/src/log/log.go?name=release#261)

```go
func SetPrefix(prefix string)
```

SetPrefix设置标准logger的输出前缀。

### func [SetOutput](https://github.com/golang/go/blob/master/src/log/log.go?name=release#239)

```go
func SetOutput(w io.Writer)
```

SetOutput设置标准logger的输出目的地，默认是标准错误输出。

### func [Printf](https://github.com/golang/go/blob/master/src/log/log.go?name=release#275)

```go
func Printf(format string, v ...interface{})
```

Printf调用Output将生成的格式化字符串输出到标准logger，参数用和fmt.Printf相同的方法处理。

### func [Print](https://github.com/golang/go/blob/master/src/log/log.go?name=release#269)

```go
func Print(v ...interface{})
```

Print调用Output将生成的格式化字符串输出到标准logger，参数用和fmt.Print相同的方法处理。

### func [Println](https://github.com/golang/go/blob/master/src/log/log.go?name=release#281)

```go
func Println(v ...interface{})
```

Println调用Output将生成的格式化字符串输出到标准logger，参数用和fmt.Println相同的方法处理。

### func [Fatalf](https://github.com/golang/go/blob/master/src/log/log.go?name=release#292)

```go
func Fatalf(format string, v ...interface{})
```

Fatalf等价于{Printf(v...); os.Exit(1)}

### func [Fatal](https://github.com/golang/go/blob/master/src/log/log.go?name=release#286)

```go
func Fatal(v ...interface{})
```

Fatal等价于{Print(v...); os.Exit(1)}

### func [Fatalln](https://github.com/golang/go/blob/master/src/log/log.go?name=release#298)

```go
func Fatalln(v ...interface{})
```

Fatalln等价于{Println(v...); os.Exit(1)}

### func [Panicf](https://github.com/golang/go/blob/master/src/log/log.go?name=release#311)

```go
func Panicf(format string, v ...interface{})
```

Panicf等价于{Printf(v...); panic(...)}

### func [Panic](https://github.com/golang/go/blob/master/src/log/log.go?name=release#304)

```go
func Panic(v ...interface{})
```

Panic等价于{Print(v...); panic(...)}

### func [Panicln](https://github.com/golang/go/blob/master/src/log/log.go?name=release#318)

```go
func Panicln(v ...interface{})
```

Panicln等价于{Println(v...); panic(...)}

# bytes包

package bytes

import "bytes"

bytes包实现了操作[]byte的常用函数。本包的函数和strings包的函数相当类似。

### Constants

```go
const MinRead = 512
```

MinRead是被Buffer.ReadFrom传递给Read调用的最小尺寸。只要该Buffer在保存内容之外有最少MinRead字节的余量，其ReadFrom方法就不会增加底层的缓冲。

### Variables

```go
var ErrTooLarge = errors.New("bytes.Buffer: too large")
```

如果内存中不能申请足够保存数据的缓冲，ErrTooLarge就会被传递给panic函数。

### func [Compare](https://github.com/golang/go/blob/master/src/bytes/bytes_decl.go?name=release#24)

```go
func Compare(a, b []byte) int
```

Compare函数返回一个整数表示两个[]byte切片按字典序比较的结果（类同C的strcmp）。如果a==b返回0；如果a<b返回-1；否则返回+1。nil参数视为空切片。

Example

```go
// Interpret Compare's result by comparing it to zero.
var a, b []byte
if bytes.Compare(a, b) < 0 {
    // a less b
}
if bytes.Compare(a, b) <= 0 {
    // a less or equal b
}
if bytes.Compare(a, b) > 0 {
    // a greater b
}
if bytes.Compare(a, b) >= 0 {
    // a greater or equal b
}
// Prefer Equal to Compare for equality comparisons.
if bytes.Equal(a, b) {
    // a equal b
}
if !bytes.Equal(a, b) {
    // a not equal b
}
```

Example (Search)

```go
// Binary search to find a matching byte slice.
var needle []byte
var haystack [][]byte // Assume sorted
i := sort.Search(len(haystack), func(i int) bool {
    // Return haystack[i] >= needle.
    return bytes.Compare(haystack[i], needle) >= 0
})
if i < len(haystack) && bytes.Equal(haystack[i], needle) {
    // Found it!
}
```

### func [Equal](https://github.com/golang/go/blob/master/src/bytes/bytes_decl.go?name=release#17)

```go
func Equal(a, b []byte) bool
```

判断两个切片的内容是否完全相同。

### func [EqualFold](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#646)

```go
func EqualFold(s, t []byte) bool
```

判断两个utf-8编码切片（将unicode大写、小写、标题三种格式字符视为相同）是否相同。

### func [Runes](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#593)

```go
func Runes(s []byte) []rune
```

Runes函数返回和s等价的[]rune切片。（将utf-8编码的unicode码值分别写入单个rune）

### func [HasPrefix](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#331)

```go
func HasPrefix(s, prefix []byte) bool
```

判断s是否有前缀切片prefix。

### func [HasSuffix](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#336)

```go
func HasSuffix(s, suffix []byte) bool
```

判断s是否有后缀切片suffix。

### func [Contains](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#81)

```go
func Contains(b, subslice []byte) bool
```

判断切片b是否包含子切片subslice。

### func [Count](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#50)

```go
func Count(s, sep []byte) int
```

Count计算s中有多少个不重叠的sep子切片。

### func [Index](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#86)

```go
func Index(s, sep []byte) int
```

子切片sep在s中第一次出现的位置，不存在则返回-1。

### func [IndexByte](https://github.com/golang/go/blob/master/src/bytes/bytes_decl.go?name=release#10)

```go
func IndexByte(s []byte, c byte) int
```

字符c在s中第一次出现的位置，不存在则返回-1。

### func [IndexRune](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#143)

```go
func IndexRune(s []byte, r rune) int
```

unicode字符r的utf-8编码在s中第一次出现的位置，不存在则返回-1。

### func [IndexAny](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#158)

```go
func IndexAny(s []byte, chars string) int
```

字符串chars中的任一utf-8编码在s中第一次出现的位置，如不存在或者chars为空字符串则返回-1

### func [IndexFunc](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#510)

```go
func IndexFunc(s []byte, f func(r rune) bool) int
```

s中第一个满足函数f的位置i（该处的utf-8码值r满足f(r)==true），不存在则返回-1

### func [LastIndex](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#126)

```go
func LastIndex(s, sep []byte) int
```

切片sep在字符串s中最后一次出现的位置，不存在则返回-1。

### func [LastIndexAny](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#183)

```go
func LastIndexAny(s []byte, chars string) int
```

字符串chars中的任一utf-8字符在s中最后一次出现的位置，如不存在或者chars为空字符串则返回-1。

### func [LastIndexFunc](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#517)

```go
func LastIndexFunc(s []byte, f func(r rune) bool) int
```

s中最后一个满足函数f的unicode码值的位置i，不存在则返回-1。

### func [Title](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#443)

```go
func Title(s []byte) []byte
```

返回s中每个单词的首字母都改为标题格式的拷贝。

BUG: Title用于划分单词的规则不能很好的处理Unicode标点符号。

### func [ToLower](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#391)

```go
func ToLower(s []byte) []byte
```

返回将所有字母都转为对应的小写版本的拷贝。

### func [ToLowerSpecial](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#404)

```go
func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte
```

使用_case规定的字符映射，返回将所有字母都转为对应的小写版本的拷贝。

### func [ToUpper](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#388)

```go
func ToUpper(s []byte) []byte
```

返回将所有字母都转为对应的大写版本的拷贝。

### func [ToUpperSpecial](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#398)

```go
func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte
```

使用_case规定的字符映射，返回将所有字母都转为对应的大写版本的拷贝。

### func [ToTitle](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#394)

```go
func ToTitle(s []byte) []byte
```

返回将所有字母都转为对应的标题版本的拷贝。

### func [ToTitleSpecial](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#410)

```go
func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte
```

使用_case规定的字符映射，返回将所有字母都转为对应的标题版本的拷贝。

### func [Repeat](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#378)

```go
func Repeat(b []byte, count int) []byte
```

返回count个b串联形成的新的切片。

### func [Replace](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#608)

```go
func Replace(s, old, new []byte, n int) []byte
```

返回将s中前n个不重叠old切片序列都替换为new的新的切片拷贝，如果n<0会替换所有old子切片。

### func [Map](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#344)

```go
func Map(mapping func(r rune) rune, s []byte) []byte
```

将s的每一个unicode码值r都替换为mapping(r)，返回这些新码值组成的切片拷贝。如果mapping返回一个负值，将会丢弃该码值而不会被替换（返回值中对应位置将没有码值）。

### func [Trim](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#570)

```go
func Trim(s []byte, cutset string) []byte
```

返回将s前后端所有cutset包含的unicode码值都去掉的子切片。（共用底层数组）

### func [TrimSpace](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#588)

```go
func TrimSpace(s []byte) []byte
```

返回将s前后端所有空白（unicode.IsSpace指定）都去掉的子切片。（共用底层数组）

### func [TrimFunc](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#485)

```go
func TrimFunc(s []byte, f func(r rune) bool) []byte
```

返回将s前后端所有满足f的unicode码值都去掉的子切片。（共用底层数组）

### func [TrimLeft](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#576)

```go
func TrimLeft(s []byte, cutset string) []byte
```

返回将s前端所有cutset包含的unicode码值都去掉的子切片。（共用底层数组）

### func [TrimLeftFunc](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#462)

```go
func TrimLeftFunc(s []byte, f func(r rune) bool) []byte
```

返回将s前端所有满足f的unicode码值都去掉的子切片。（共用底层数组）

### func [TrimPrefix](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#491)

```go
func TrimPrefix(s, prefix []byte) []byte
```

返回去除s可能的前缀prefix的子切片。（共用底层数组）

Example

```go
var b = []byte("Goodbye,, world!")
b = bytes.TrimPrefix(b, []byte("Goodbye,"))
b = bytes.TrimPrefix(b, []byte("See ya,"))
fmt.Printf("Hello%s", b)
```

Output:

```go
Hello, world!
```

### func [TrimRight](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#582)

```go
func TrimRight(s []byte, cutset string) []byte
```

返回将s后端所有cutset包含的unicode码值都去掉的子切片。（共用底层数组）

### func [TrimRightFunc](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#472)

```go
func TrimRightFunc(s []byte, f func(r rune) bool) []byte
```

返回将s后端所有满足f的unicode码值都去掉的子切片。（共用底层数组）

### func [TrimSuffix](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#500)

```go
func TrimSuffix(s, suffix []byte) []byte
```

返回去除s可能的后缀suffix的子切片。（共用底层数组）

Example

```go
var b = []byte("Hello, goodbye, etc!")
b = bytes.TrimSuffix(b, []byte("goodbye, etc!"))
b = bytes.TrimSuffix(b, []byte("gopher"))
b = append(b, bytes.TrimSuffix([]byte("world!"), []byte("x!"))...)
os.Stdout.Write(b)
```

Output:

```go
Hello, world!
```

### func [Fields](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#262)

```go
func Fields(s []byte) [][]byte
```

返回将字符串按照空白（unicode.IsSpace确定，可以是一到多个连续的空白字符）分割的多个子切片。如果字符串全部是空白或者是空字符串的话，会返回空切片。

### func [FieldsFunc](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#270)

```go
func FieldsFunc(s []byte, f func(rune) bool) [][]byte
```

类似Fields，但使用函数f来确定分割符（满足f的utf-8码值）。如果字符串全部是分隔符或者是空字符串的话，会返回空切片。

### func [Split](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#250)

```go
func Split(s, sep []byte) [][]byte
```

用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所有[]byte切片组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个[]byte切片。

### func [SplitN](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#233)

```go
func SplitN(s, sep []byte, n int) [][]byte
```

用去掉s中出现的sep的方式进行分割，会分割到最多n个子切片，并返回生成的所有[]byte切片组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个[]byte切片。参数n决定返回的切片的数目：

```go
n > 0 : 返回的切片最多n个子字符串；最后一个子字符串包含未进行切割的部分。
n == 0: 返回nil
n < 0 : 返回所有的子字符串组成的切片
```

### func [SplitAfter](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#256)

```go
func SplitAfter(s, sep []byte) [][]byte
```

用从s中出现的sep后面切断的方式进行分割，会分割到结尾，并返回生成的所有[]byte切片组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个[]byte切片。

### func [SplitAfterN](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#242)

```go
func SplitAfterN(s, sep []byte, n int) [][]byte
```

用从s中出现的sep后面切断的方式进行分割，会分割到最多n个子切片，并返回生成的所有[]byte切片组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个[]byte切片。参数n决定返回的切片的数目：

```go
n > 0 : 返回的切片最多n个子字符串；最后一个子字符串包含未进行切割的部分。
n == 0: 返回nil
n < 0 : 返回所有的子字符串组成的切片
```

### func [Join](https://github.com/golang/go/blob/master/src/bytes/bytes.go?name=release#308)

```go
func Join(s [][]byte, sep []byte) []byte
```

将一系列[]byte切片连接为一个[]byte切片，之间用sep来分隔，返回生成的新切片。

### type [Reader](https://github.com/golang/go/blob/master/src/bytes/reader.go?name=release#17)

```go
type Reader struct {
    // 内含隐藏或非导出字段
}
```

Reader类型通过从一个[]byte读取数据，实现了io.Reader、io.Seeker、io.ReaderAt、io.WriterTo、io.ByteScanner、io.RuneScanner接口。

#### func [NewReader](https://github.com/golang/go/blob/master/src/bytes/reader.go?name=release#144)

```go
func NewReader(b []byte) *Reader
```

NewReader创建一个从s读取数据的Reader。

#### func (*Reader) [Len](https://github.com/golang/go/blob/master/src/bytes/reader.go?name=release#25)

```go
func (r *Reader) Len() int
```

Len返回r包含的切片中还没有被读取的部分。

#### func (*Reader) [Read](https://github.com/golang/go/blob/master/src/bytes/reader.go?name=release#32)

```go
func (r *Reader) Read(b []byte) (n int, err error)
```

#### func (*Reader) [ReadByte](https://github.com/golang/go/blob/master/src/bytes/reader.go?name=release#60)

```go
func (r *Reader) ReadByte() (b byte, err error)
```

#### func (*Reader) [UnreadByte](https://github.com/golang/go/blob/master/src/bytes/reader.go?name=release#70)

```go
func (r *Reader) UnreadByte() error
```

#### func (*Reader) [ReadRune](https://github.com/golang/go/blob/master/src/bytes/reader.go?name=release#79)

```go
func (r *Reader) ReadRune() (ch rune, size int, err error)
```

#### func (*Reader) [UnreadRune](https://github.com/golang/go/blob/master/src/bytes/reader.go?name=release#94)

```go
func (r *Reader) UnreadRune() error
```

#### func (*Reader) [Seek](https://github.com/golang/go/blob/master/src/bytes/reader.go?name=release#104)

```go
func (r *Reader) Seek(offset int64, whence int) (int64, error)
```

Seek实现了io.Seeker接口。

#### func (*Reader) [ReadAt](https://github.com/golang/go/blob/master/src/bytes/reader.go?name=release#45)

```go
func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)
```

#### func (*Reader) [WriteTo](https://github.com/golang/go/blob/master/src/bytes/reader.go?name=release#125)

```go
func (r *Reader) WriteTo(w io.Writer) (n int64, err error)
```

WriteTo实现了io.WriterTo接口。

### type [Buffer](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#17)

```go
type Buffer struct {
    // 内含隐藏或非导出字段
}
```

Buffer是一个实现了读写方法的可变大小的字节缓冲。本类型的零值是一个空的可用于读写的缓冲。

Example

```go
var b bytes.Buffer // A Buffer needs no initialization.
b.Write([]byte("Hello "))
fmt.Fprintf(&b, "world!")
b.WriteTo(os.Stdout)
```

Output:

```go
Hello world!
```

Example (Reader)

```go
// A Buffer can turn a string or a []byte into an io.Reader.
buf := bytes.NewBufferString("R29waGVycyBydWxlIQ==")
dec := base64.NewDecoder(base64.StdEncoding, buf)
io.Copy(os.Stdout, dec)
```

Output:

```
Gophers rule!
```

#### func [NewBuffer](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#402)

```go
func NewBuffer(buf []byte) *Buffer
```

NewBuffer使用buf作为初始内容创建并初始化一个Buffer。本函数用于创建一个用于读取已存在数据的buffer；也用于指定用于写入的内部缓冲的大小，此时，buf应为一个具有指定容量但长度为0的切片。buf会被作为返回值的底层缓冲切片。

大多数情况下，new(Buffer)（或只是声明一个Buffer类型变量）就足以初始化一个Buffer了。

#### func [NewBufferString](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#410)

```go
func NewBufferString(s string) *Buffer
```

NewBuffer使用s作为初始内容创建并初始化一个Buffer。本函数用于创建一个用于读取已存在数据的buffer。

大多数情况下，new(Buffer)（或只是声明一个Buffer类型变量）就足以初始化一个Buffer了。

#### func (*Buffer) [Reset](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#75)

```go
func (b *Buffer) Reset()
```

Reset重设缓冲，因此会丢弃全部内容，等价于b.Truncate(0)。

#### func (*Buffer) [Len](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#57)

```go
func (b *Buffer) Len() int
```

返回缓冲中未读取部分的字节长度；b.Len() == len(b.Bytes())。

#### func (*Buffer) [Bytes](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#43)

```go
func (b *Buffer) Bytes() []byte
```

返回未读取部分字节数据的切片，len(b.Bytes()) == b.Len()。如果中间没有调用其他方法，修改返回的切片的内容会直接改变Buffer的内容。

#### func (*Buffer) [String](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#47)

```go
func (b *Buffer) String() string
```

将未读取部分的字节数据作为字符串返回，如果b是nil指针，会返回"<nil>"。

#### func (*Buffer) [Truncate](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#61)

```go
func (b *Buffer) Truncate(n int)
```

丢弃缓冲中除前n字节数据外的其它数据，如果n小于零或者大于缓冲容量将panic。

#### func (*Buffer) [Grow](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#114)

```go
func (b *Buffer) Grow(n int)
```

必要时会增加缓冲的容量，以保证n字节的剩余空间。调用Grow(n)后至少可以向缓冲中写入n字节数据而无需申请内存。如果n小于零或者不能增加容量都会panic。

#### func (*Buffer) [Read](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#251)

```go
func (b *Buffer) Read(p []byte) (n int, err error)
```

Read方法从缓冲中读取数据直到缓冲中没有数据或者读取了len(p)字节数据，将读取的数据写入p。返回值n是读取的字节数，除非缓冲中完全没有数据可以读取并写入p，此时返回值err为io.EOF；否则err总是nil。

#### func (*Buffer) [Next](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#273)

```go
func (b *Buffer) Next(n int) []byte
```

返回未读取部分前n字节数据的切片，并且移动读取位置，就像调用了Read方法一样。如果缓冲内数据不足，会返回整个数据的切片。切片只在下一次调用b的读/写方法前才合法。

#### func (*Buffer) [ReadByte](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#289)

```go
func (b *Buffer) ReadByte() (c byte, err error)
```

ReadByte读取并返回缓冲中的下一个字节。如果没有数据可用，返回值err为io.EOF。

#### func (*Buffer) [UnreadByte](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#345)

```go
func (b *Buffer) UnreadByte() error
```

UnreadByte吐出最近一次读取操作读取的最后一个字节。如果最后一次读取操作之后进行了写入，本方法会返回错误。

#### func (*Buffer) [ReadRune](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#307)

```go
func (b *Buffer) ReadRune() (r rune, size int, err error)
```

ReadRune读取并返回缓冲中的下一个utf-8码值。如果没有数据可用，返回值err为io.EOF。如果缓冲中的数据是错误的utf-8编码，本方法会吃掉一字节并返回(U+FFFD, 1, nil)。

#### func (*Buffer) [UnreadRune](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#330)

```go
func (b *Buffer) UnreadRune() error
```

UnreadRune吐出最近一次调用ReadRune方法读取的unicode码值。如果最近一次读写操作不是ReadRune，本方法会返回错误。（这里就能看出来UnreadRune比UnreadByte严格多了）

#### func (*Buffer) [ReadBytes](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#362)

```go
func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)
```

ReadBytes读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的切片。如果ReadBytes方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadBytes方法返回的切片不以delim结尾时，会返回一个非nil的错误。

#### func (*Buffer) [ReadString](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#390)

```go
func (b *Buffer) ReadString(delim byte) (line string, err error)
```

ReadString读取直到第一次遇到delim字节，返回一个包含已读取的数据和delim字节的字符串。如果ReadString方法在读取到delim之前遇到了错误，它会返回在错误之前读取的数据以及该错误（一般是io.EOF）。当且仅当ReadString方法返回的切片不以delim结尾时，会返回一个非nil的错误。

#### func (*Buffer) [Write](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#125)

```go
func (b *Buffer) Write(p []byte) (n int, err error)
```

Write将p的内容写入缓冲中，如必要会增加缓冲容量。返回值n为len(p)，err总是nil。如果缓冲变得太大，Write会采用错误值ErrTooLarge引发panic。

#### func (*Buffer) [WriteString](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#134)

```go
func (b *Buffer) WriteString(s string) (n int, err error)
```

Write将s的内容写入缓冲中，如必要会增加缓冲容量。返回值n为len(p)，err总是nil。如果缓冲变得太大，Write会采用错误值ErrTooLarge引发panic。

#### func (*Buffer) [WriteByte](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#226)

```go
func (b *Buffer) WriteByte(c byte) error
```

WriteByte将字节c写入缓冲中，如必要会增加缓冲容量。返回值总是nil，但仍保留以匹配bufio.Writer的WriteByte方法。如果缓冲太大，WriteByte会采用错误值ErrTooLarge引发panic。

#### func (*Buffer) [WriteRune](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#237)

```go
func (b *Buffer) WriteRune(r rune) (n int, err error)
```

WriteByte将unicode码值r的utf-8编码写入缓冲中，如必要会增加缓冲容量。返回值总是nil，但仍保留以匹配bufio.Writer的WriteRune方法。如果缓冲太大，WriteRune会采用错误值ErrTooLarge引发panic。

#### func (*Buffer) [ReadFrom](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#150)

```go
func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)
```

ReadFrom从r中读取数据直到结束并将读取的数据写入缓冲中，如必要会增加缓冲容量。返回值n为从r读取并写入b的字节数；会返回读取时遇到的除了io.EOF之外的错误。如果缓冲太大，ReadFrom会采用错误值ErrTooLarge引发panic。

#### func (*Buffer) [WriteTo](https://github.com/golang/go/blob/master/src/bytes/buffer.go?name=release#198)

```go
func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)
```

WriteTo从缓冲中读取数据直到缓冲内没有数据或遇到错误，并将这些数据写入w。返回值n为从b读取并写入w的字节数；返回值总是可以无溢出的写入int类型，但为了匹配io.WriterTo接口设为int64类型。从b读取是遇到的非io.EOF错误及写入w时遇到的错误都会终止本方法并返回该错误。

# strings包

package strings

import "strings"

strings包实现了用于操作字符的简单函数。

###  func [EqualFold](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#674)

```go
func EqualFold(s, t string) bool
```

判断两个utf-8编码字符串（将unicode大写、小写、标题三种格式字符视为相同）是否相同。

Example

```go
fmt.Println(strings.EqualFold("Go", "go"))
```

Output:

```go
true
```

### func [HasPrefix](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#371)

```go
func HasPrefix(s, prefix string) bool
```

判断s是否有前缀字符串prefix。

### func [HasSuffix](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#376)

```go
func HasSuffix(s, suffix string) bool
```

判断s是否有后缀字符串suffix。

### func [Contains](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#112)

```go
func Contains(s, substr string) bool
```

判断字符串s是否包含子串substr。

Example

```go
fmt.Println(strings.Contains("seafood", "foo"))
fmt.Println(strings.Contains("seafood", "bar"))
fmt.Println(strings.Contains("seafood", ""))
fmt.Println(strings.Contains("", ""))
```

Output:

```go
true
false
true
true
```

### func [ContainsRune](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#122)

```go
func ContainsRune(s string, r rune) bool
```

判断字符串s是否包含utf-8码值r。

### func [ContainsAny](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#117)

```go
func ContainsAny(s, chars string) bool
```

判断字符串s是否包含字符串chars中的任一字符。

Example

```go
fmt.Println(strings.ContainsAny("team", "i"))
fmt.Println(strings.ContainsAny("failure", "u & i"))
fmt.Println(strings.ContainsAny("foo", ""))
fmt.Println(strings.ContainsAny("", ""))
```

Output:

```go
false
true
false
false
```

### func [Count](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#65)

```go
func Count(s, sep string) int
```

返回字符串s中有几个不重复的sep子串。

Example

### func [Index](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#127)

```go
func Index(s, sep string) int
```

子串sep在字符串s中第一次出现的位置，不存在则返回-1。

Example

```go
fmt.Println(strings.Index("chicken", "ken"))
fmt.Println(strings.Index("chicken", "dmr"))
```

Output:

```go
4
-1
```

### func [IndexByte](https://github.com/golang/go/blob/master/src/strings/strings_decl.go?name=release#8)

```go
func IndexByte(s string, c byte) int
```

字符c在s中第一次出现的位置，不存在则返回-1。

### func [IndexRune](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#190)

```go
func IndexRune(s string, r rune) int
```

unicode码值r在s中第一次出现的位置，不存在则返回-1。

Example

```go
fmt.Println(strings.IndexRune("chicken", 'k'))
fmt.Println(strings.IndexRune("chicken", 'd'))
```

Output:

```go
4
-1
```

### func [IndexAny](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#211)

```go
func IndexAny(s, chars string) int
```

字符串chars中的任一utf-8码值在s中第一次出现的位置，如果不存在或者chars为空字符串则返回-1。

Example

```go
fmt.Println(strings.IndexAny("chicken", "aeiouy"))
fmt.Println(strings.IndexAny("crwth", "aeiouy"))
```

Output:

```go
2
-1
```

### func [IndexFunc](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#537)

```go
func IndexFunc(s string, f func(rune) bool) int
```

s中第一个满足函数f的位置i（该处的utf-8码值r满足f(r)==true），不存在则返回-1。

Example

```go
f := func(c rune) bool {
    return unicode.Is(unicode.Han, c)
}
fmt.Println(strings.IndexFunc("Hello, 世界", f))
fmt.Println(strings.IndexFunc("Hello, world", f))
```

Output:

```go
7
-1
```

### func [LastIndex](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#164)

```go
func LastIndex(s, sep string) int
```

子串sep在字符串s中最后一次出现的位置，不存在则返回-1。

Example

```go
fmt.Println(strings.Index("go gopher", "go"))
fmt.Println(strings.LastIndex("go gopher", "go"))
fmt.Println(strings.LastIndex("go gopher", "rodent"))
```

Output:

```go
0
3
-1
```

### func [LastIndexAny](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#227)

```go
func LastIndexAny(s, chars string) int
```

字符串chars中的任一utf-8码值在s中最后一次出现的位置，如不存在或者chars为空字符串则返回-1。

### func [LastIndexFunc](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#543)

```go
func LastIndexFunc(s string, f func(rune) bool) int
```

s中最后一个满足函数f的unicode码值的位置i，不存在则返回-1。

### func [Title](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#489)

```go
func Title(s string) string
```

返回s中每个单词的首字母都改为标题格式的字符串拷贝。

BUG: Title用于划分单词的规则不能很好的处理Unicode标点符号。

Example

```go
fmt.Println(strings.Title("her royal highness"))
```

Output:

```go
Her Royal Highness
```

### func [ToLower](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#437)

```go
func ToLower(s string) string
```

返回将所有字母都转为对应的小写版本的拷贝。

Example

```go
fmt.Println(strings.ToLower("Gopher"))
```

Output:

```go
gopher
```

### func [ToLowerSpecial](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#450)

```go
func ToLowerSpecial(_case unicode.SpecialCase, s string) string
```

使用_case规定的字符映射，返回将所有字母都转为对应的小写版本的拷贝。

### func [ToUpper](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#434)

```go
func ToUpper(s string) string
```

返回将所有字母都转为对应的大写版本的拷贝。

Example

```go
fmt.Println(strings.ToUpper("Gopher"))
```

Output:

```go
GOPHER
```

### func [ToUpperSpecial](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#444)

```go
func ToUpperSpecial(_case unicode.SpecialCase, s string) string
```

使用_case规定的字符映射，返回将所有字母都转为对应的大写版本的拷贝。

### func [ToTitle](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#440)

```go
func ToTitle(s string) string
```

返回将所有字母都转为对应的标题版本的拷贝。

Example

```go
fmt.Println(strings.ToTitle("loud noises"))
fmt.Println(strings.ToTitle("хлеб"))
```

Output:

```go
LOUD NOISES
ХЛЕБ
```

### func [ToTitleSpecial](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#456)

```go
func ToTitleSpecial(_case unicode.SpecialCase, s string) string
```

使用_case规定的字符映射，返回将所有字母都转为对应的标题版本的拷贝。

### func [Repeat](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#424)

```go
func Repeat(s string, count int) string
```

返回count个s串联的字符串。

Example

```go
fmt.Println("ba" + strings.Repeat("na", 2))
```

Output:

```go
banana
```

### func [Replace](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#638)

```go
func Replace(s, old, new string, n int) string
```

返回将s中前n个不重叠old子串都替换为new的新字符串，如果n<0会替换所有old子串。

Example

```go
fmt.Println(strings.Replace("oink oink oink", "k", "ky", 2))
fmt.Println(strings.Replace("oink oink oink", "oink", "moo", -1))
```

Output:

```go
oinky oinky oink
moo moo moo
```

### func [Map](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#383)

```go
func Map(mapping func(rune) rune, s string) string
```

将s的每一个unicode码值r都替换为mapping(r)，返回这些新码值组成的字符串拷贝。如果mapping返回一个负值，将会丢弃该码值而不会被替换。（返回值中对应位置将没有码值）

Example

```go
rot13 := func(r rune) rune {
    switch {
    case r >= 'A' && r <= 'Z':
        return 'A' + (r-'A'+13)%26
    case r >= 'a' && r <= 'z':
        return 'a' + (r-'a'+13)%26
    }
    return r
}
fmt.Println(strings.Map(rot13, "'Twas brillig and the slithy gopher..."))
```

Output:

```go
'Gjnf oevyyvt naq gur fyvgul tbcure...
```

### func [Trim](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#586)

```go
func Trim(s string, cutset string) string
```

返回将s前后端所有cutset包含的utf-8码值都去掉的字符串。

Example

```go
fmt.Printf("[%q]", strings.Trim(" !!! Achtung! Achtung! !!! ", "! "))
```

Output:

```gio
["Achtung! Achtung"]
```

### func [TrimSpace](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#613)

```go
func TrimSpace(s string) string
```

返回将s前后端所有空白（unicode.IsSpace指定）都去掉的字符串。

Example

```go
fmt.Println(strings.TrimSpace(" \t\n a lone gopher \n\t\r\n"))
```

Output:

```go
a lone gopher
```

### func [TrimFunc](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#531)

```go
func TrimFunc(s string, f func(rune) bool) string
```

返回将s前后端所有满足f的unicode码值都去掉的字符串。

### func [TrimLeft](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#595)

```go
func TrimLeft(s string, cutset string) string
```

返回将s前端所有cutset包含的utf-8码值都去掉的字符串。

### func [TrimLeftFunc](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#508)

```go
func TrimLeftFunc(s string, f func(rune) bool) string
```

返回将s前端所有满足f的unicode码值都去掉的字符串。

### func [TrimPrefix](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#619)

```go
func TrimPrefix(s, prefix string) string
```

返回去除s可能的前缀prefix的字符串。

Example

```go
var s = "Goodbye,, world!"
s = strings.TrimPrefix(s, "Goodbye,")
s = strings.TrimPrefix(s, "Howdy,")
fmt.Print("Hello" + s)
```

Output:

```go
Hello, world!
```

### func [TrimRight](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#604)

```go
func TrimRight(s string, cutset string) string
```

返回将s后端所有cutset包含的utf-8码值都去掉的字符串。

### func [TrimRightFunc](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#518)

```go
func TrimRightFunc(s string, f func(rune) bool) string
```

返回将s后端所有满足f的unicode码值都去掉的字符串。

### func [TrimSuffix](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#628)

```go
func TrimSuffix(s, suffix string) string
```

返回去除s可能的后缀suffix的字符串。

Example

```go
var s = "Hello, goodbye, etc!"
s = strings.TrimSuffix(s, "goodbye, etc!")
s = strings.TrimSuffix(s, "planet")
fmt.Print(s, "world!")
```

Output:

```go
Hello, world!
```

### func [Fields](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#307)

```go
func Fields(s string) []string
```

返回将字符串按照空白（unicode.IsSpace确定，可以是一到多个连续的空白字符）分割的多个字符串。如果字符串全部是空白或者是空字符串的话，会返回空切片。

Example

```go
fmt.Printf("Fields are: %q", strings.Fields("  foo bar  baz   "))
```

Output:

```go
Fields are: ["foo" "bar" "baz"]
```

### func [FieldsFunc](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#314)

```go
func FieldsFunc(s string, f func(rune) bool) []string
```

类似Fields，但使用函数f来确定分割符（满足f的unicode码值）。如果字符串全部是分隔符或者是空字符串的话，会返回空切片。

Example

```go
f := func(c rune) bool {
    return !unicode.IsLetter(c) && !unicode.IsNumber(c)
}
fmt.Printf("Fields are: %q", strings.FieldsFunc("  foo1;bar2,baz3...", f))
```

Output:

```go
Fields are: ["foo1" "bar2" "baz3"]
```

### func [Split](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#294)

```go
func Split(s, sep string) []string
```

用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所有片段组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个字符串。

Example

```go
fmt.Printf("%q\n", strings.Split("a,b,c", ","))
fmt.Printf("%q\n", strings.Split("a man a plan a canal panama", "a "))
fmt.Printf("%q\n", strings.Split(" xyz ", ""))
fmt.Printf("%q\n", strings.Split("", "Bernardo O'Higgins"))
```

Output:

```go
["a" "b" "c"]
["" "man " "plan " "canal panama"]
[" " "x" "y" "z" " "]
[""]
```

### func [SplitN](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#277)

```go
func SplitN(s, sep string, n int) []string
```

用去掉s中出现的sep的方式进行分割，会分割到结尾，并返回生成的所有片段组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个字符串。参数n决定返回的切片的数目：

```go
n > 0 : 返回的切片最多n个子字符串；最后一个子字符串包含未进行切割的部分。
n == 0: 返回nil
n < 0 : 返回所有的子字符串组成的切片
```

Example

```go
fmt.Printf("%q\n", strings.SplitN("a,b,c", ",", 2))
z := strings.SplitN("a,b,c", ",", 0)
fmt.Printf("%q (nil = %v)\n", z, z == nil)
```

Output:

```go
["a" "b,c"]
[] (nil = true)
```

### func [SplitAfter](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#300)

```go
func SplitAfter(s, sep string) []string
```

用从s中出现的sep后面切断的方式进行分割，会分割到结尾，并返回生成的所有片段组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个字符串。

Example

```go
fmt.Printf("%q\n", strings.SplitAfter("a,b,c", ","))
```

Output:

```go
["a," "b," "c"]
```

### func [SplitAfterN](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#286)

```go
func SplitAfterN(s, sep string, n int) []string
```

用从s中出现的sep后面切断的方式进行分割，会分割到结尾，并返回生成的所有片段组成的切片（每一个sep都会进行一次切割，即使两个sep相邻，也会进行两次切割）。如果sep为空字符，Split会将s切分成每一个unicode码值一个字符串。参数n决定返回的切片的数目：

```go
n > 0 : 返回的切片最多n个子字符串；最后一个子字符串包含未进行切割的部分。
n == 0: 返回nil
n < 0 : 返回所有的子字符串组成的切
```

Example

```go
fmt.Printf("%q\n", strings.SplitAfterN("a,b,c", ",", 2))
```

Output:

```go
["a," "b,c"]
```

### func [Join](https://github.com/golang/go/blob/master/src/strings/strings.go?name=release#349)

```go
func Join(a []string, sep string) string
```

将一系列字符串连接为一个字符串，之间用sep来分隔。

Example

```go
s := []string{"foo", "bar", "baz"}
fmt.Println(strings.Join(s, ", "))
```

Output:

```go
foo, bar, baz
```

### type [Reader](https://github.com/golang/go/blob/master/src/strings/reader.go?name=release#16)

```go
type Reader struct {
    // 内含隐藏或非导出字段
}
```

Reader类型通过从一个字符串读取数据，实现了io.Reader、io.Seeker、io.ReaderAt、io.WriterTo、io.ByteScanner、io.RuneScanner接口。

#### func [NewReader](https://github.com/golang/go/blob/master/src/strings/reader.go?name=release#144)

```go
func NewReader(s string) *Reader
```

NewReader创建一个从s读取数据的Reader。本函数类似bytes.NewBufferString，但是更有效率，且为只读的。

#### func (*Reader) [Len](https://github.com/golang/go/blob/master/src/strings/reader.go?name=release#24)

```go
func (r *Reader) Len() int
```

Len返回r包含的字符串还没有被读取的部分。

#### func (*Reader) [Read](https://github.com/golang/go/blob/master/src/strings/reader.go?name=release#31)

```go
func (r *Reader) Read(b []byte) (n int, err error)
```

#### func (*Reader) [ReadByte](https://github.com/golang/go/blob/master/src/strings/reader.go?name=release#59)

```go
func (r *Reader) ReadByte() (b byte, err error)
```

#### func (*Reader) [UnreadByte](https://github.com/golang/go/blob/master/src/strings/reader.go?name=release#69)

```go
func (r *Reader) UnreadByte() error
```

#### func (*Reader) [ReadRune](https://github.com/golang/go/blob/master/src/strings/reader.go?name=release#78)

```go
func (r *Reader) ReadRune() (ch rune, size int, err error)
```

#### func (*Reader) [UnreadRune](https://github.com/golang/go/blob/master/src/strings/reader.go?name=release#93)

```go
func (r *Reader) UnreadRune() error
```

#### func (*Reader) [Seek](https://github.com/golang/go/blob/master/src/strings/reader.go?name=release#103)

```go
func (r *Reader) Seek(offset int64, whence int) (int64, error)
```

Seek实现了io.Seeker接口。

#### func (*Reader) [ReadAt](https://github.com/golang/go/blob/master/src/strings/reader.go?name=release#44)

```go
func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)
```

#### func (*Reader) [WriteTo](https://github.com/golang/go/blob/master/src/strings/reader.go?name=release#124)

```go
func (r *Reader) WriteTo(w io.Writer) (n int64, err error)
```

WriteTo实现了io.WriterTo接口。

### type [Replacer](https://github.com/golang/go/blob/master/src/strings/replace.go?name=release#10)

```go
type Replacer struct {
    // 内含隐藏或非导出字段
}
```

Replacer类型进行一系列字符串的替换。

#### func [NewReplacer](https://github.com/golang/go/blob/master/src/strings/replace.go?name=release#31)

```go
func NewReplacer(oldnew ...string) *Replacer
```

使用提供的多组old、new字符串对创建并返回一个*Replacer。替换是依次进行的，匹配时不会重叠。

Example

```go
r := strings.NewReplacer("<", "&lt;", ">", "&gt;")
fmt.Println(r.Replace("This is <b>HTML</b>!"))
```

Output:

```go
This is &lt;b&gt;HTML&lt;/b&gt;!
```

#### func (*Replacer) [Replace](https://github.com/golang/go/blob/master/src/strings/replace.go?name=release#78)

```go
func (r *Replacer) Replace(s string) string
```

Replace返回s的所有替换进行完后的拷贝。

#### func (*Replacer) [WriteString](https://github.com/golang/go/blob/master/src/strings/replace.go?name=release#83)

```go
func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)
```

WriteString向w中写入s的所有替换进行完后的拷贝。

# fmt包

package fmt

```go
import "fmt"
```

mt包实现了类似C语言printf和scanf的格式化I/O。格式化动作（'verb'）源自C语言但更简单。

#### Printing

verb：

通用：

```go
%v	值的默认格式表示
%+v	类似%v，但输出结构体时会添加字段名
%#v	值的Go语法表示
%T	值的类型的Go语法表示
%%	百分号
```

布尔值：

```go
%t	单词true或false
```

整数：

```go
%b	表示为二进制
%c	该值对应的unicode码值
%d	表示为十进制
%o	表示为八进制
%q	该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示
%x	表示为十六进制，使用a-f
%X	表示为十六进制，使用A-F
%U	表示为Unicode格式：U+1234，等价于"U+%04X"
```

浮点数与复数的两个组分：

```go
%b	无小数部分、二进制指数的科学计数法，如-123456p-78；参见strconv.FormatFloat
%e	科学计数法，如-1234.456e+78
%E	科学计数法，如-1234.456E+78
%f	有小数部分但无指数部分，如123.456
%F	等价于%f
%g	根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）
%G	根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）
```

字符串和[]byte：

```go
%s	直接输出字符串或者[]byte
%q	该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示
%x	每个字节用两字符十六进制数表示（使用a-f）
%X	每个字节用两字符十六进制数表示（使用A-F）    
```

指针：

```go
%p	表示为十六进制，并加上前导的0x    
```

没有%u。整数如果是无符号类型自然输出也是无符号的。类似的，也没有必要指定操作数的尺寸（int8，int64）。

宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：

```go
%f:    默认宽度，默认精度
%9f    宽度9，默认精度
%.2f   默认宽度，精度2
%9.2f  宽度9，精度2
%9.f   宽度9，精度0    
```

宽度和精度格式化控制的是Unicode码值的数量（不同于C的printf，它的这两个因数指的是字节的数量）。两者任一个或两个都可以使用'*'号取代，此时它们的值将被对应的参数（按'*'号和verb出现的顺序，即控制其值的参数会出现在要表示的值前面）控制，这个操作数必须是int类型。

对于大多数类型的值，宽度是输出字符数目的最小数量，如果必要会用空格填充。对于字符串，精度是输出字符数目的最大数量，如果必要会截断字符串。

对于整数，宽度和精度都设置输出总长度。采用精度时表示右对齐并用0填充，而宽度默认表示用空格填充。

对于浮点数，宽度设置输出总长度；精度设置小数部分长度（如果有的话），除了%g和%G，此时精度设置总的数字个数。例如，对数字123.45，格式%6.2f 输出123.45；格式%.4g输出123.5。%e和%f的默认精度是6，%g的默认精度是可以将该值区分出来需要的最小数字个数。

对复数，宽度和精度会分别用于实部和虚部，结果用小括号包裹。因此%f用于1.2+3.4i输出(1.200000+3.400000i)。

其它flag：

```go
'+'	总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）；
' '	对数值，正数前加空格而负数前加负号；
'-'	在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）；
'#'	切换格式：
  	八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）；
 	对%q（%#q），如果strconv.CanBackquote返回真会输出反引号括起来的未转义字符串；
 	对%U（%#U），输出Unicode格式后，如字符可打印，还会输出空格和单引号括起来的go字面值；
  	对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格；
'0'	使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；
```

verb会忽略不支持的flag。例如，因为没有十进制切换模式，所以%#d和%d的输出是相同的。

对每一个类似Printf的函数，都有对应的Print型函数，该函数不接受格式字符串，就效果上等价于对每一个参数都是用verb %v。另一个变体Println型函数会在各个操作数的输出之间加空格并在最后换行。

不管verb如何，如果操作数是一个接口值，那么会使用接口内部保管的值，而不是接口，因此：

```go
var i interface{} = 23
fmt.Printf("%v\n", i)
```

会输出23。

除了verb %T和%p之外；对实现了特定接口的操作数会考虑采用特殊的格式化技巧。按应用优先级如下：

\1. 如果操作数实现了Formatter接口，会调用该接口的方法。Formatter提供了格式化的控制。

\2. 如果verb %v配合flag #使用（%#v），且操作数实现了GoStringer接口，会调用该接口。

如果操作数满足如下两条任一条，对于%s、%q、%v、%x、%X五个verb，将考虑：

\3. 如果操作数实现了error接口，Error方法会用来生成字符串，随后将按给出的flag（如果有）和verb格式化。

\4. 如果操作数具有String方法，这个方法将被用来生成字符串，然后将按给出的flag（如果有）和verb格式化。

复合类型的操作数，如切片和结构体，格式化动作verb递归地应用于其每一个成员，而不是作为整体一个操作数使用。因此%q会将[]string的每一个成员括起来，%6.2f会控制浮点数组的每一个元素的格式化。

为了避免可能出现的无穷递归，如：

```go
type X string
func (x X) String() string { return Sprintf("<%s>", x) }
```

应在递归之前转换值的类型：

```go
func (x X) String() string { return Sprintf("<%s>", string(x)) }
```

显式指定参数索引：

在Printf、Sprintf、Fprintf三个函数中，默认的行为是对每一个格式化verb依次对应调用时成功传递进来的参数。但是，紧跟在verb之前的[n]符号表示应格式化第n个参数（索引从1开始）。同样的在'*'之前的[n]符号表示采用第n个参数的值作为宽度或精度。在处理完方括号表达式[n]后，除非另有指示，会接着处理参数n+1，n+2……（就是说移动了当前处理位置）。例如：

```go
fmt.Sprintf("%[2]d %[1]d\n", 11, 22)
```

会生成"22 11"，而：

```go
fmt.Sprintf("%[3]*.[2]*[1]f", 12.0, 2, 6),
```

等价于：

```go
fmt.Sprintf("%6.2f", 12.0),
```

会生成" 12.00"。因为显式的索引会影响随后的verb，这种符号可以通过重设索引用于多次打印同一个值：

```go
fmt.Sprintf("%d %d %#[1]x %#x", 16, 17)
```

会生成"16 17 0x10 0x11"

格式化错误：

如果给某个verb提供了非法的参数，如给%d提供了一个字符串，生成的字符串会包含该问题的描述，如下所例：

```go
错误的类型或未知的verb：%!verb(type=value)
	Printf("%d", hi):          %!d(string=hi)
太多参数（采用索引时会失效）：%!(EXTRA type=value)
	Printf("hi", "guys"):      hi%!(EXTRA string=guys)
太少参数: %!verb(MISSING)
	Printf("hi%d"):            hi %!d(MISSING)
宽度/精度不是整数值：%!(BADWIDTH) or %!(BADPREC)
	Printf("%*s", 4.5, "hi"):  %!(BADWIDTH)hi
	Printf("%.*s", 4.5, "hi"): %!(BADPREC)hi
没有索引指向的参数：%!(BADINDEX)
	Printf("%*[2]d", 7):       %!d(BADINDEX)
	Printf("%.[2]d", 7):       %!d(BADINDEX)
```

所有的错误都以字符串"%!"开始，有时会后跟单个字符（verb标识符），并以加小括弧的描述结束。

如果被print系列函数调用时，Error或String方法触发了panic，fmt包会根据panic重建错误信息，用一个字符串说明该panic经过了fmt包。例如，一个String方法调用了panic("bad")，生成的格式化信息差不多是这样的：

```go
%!s(PANIC=bad)
```

%!s指示表示错误（panic）出现时的使用的verb。

#### Scanning

一系列类似的函数可以扫描格式化文本以生成值。

Scan、Scanf和Scanln从标准输入os.Stdin读取文本；Fscan、Fscanf、Fscanln从指定的io.Reader接口读取文本；Sscan、Sscanf、Sscanln从一个参数字符串读取文本。

Scanln、Fscanln、Sscanln会在读取到换行时停止，并要求一次提供一行所有条目；Scanf、Fscanf、Sscanf只有在格式化文本末端有换行时会读取到换行为止；其他函数会将换行视为空白。

Scanf、Fscanf、Sscanf会根据格式字符串解析参数，类似Printf。例如%x会读取一个十六进制的整数，%v会按对应值的默认格式读取。格式规则类似Printf，有如下区别：

```go
%p 未实现
%T 未实现
%e %E %f %F %g %G 效果相同，用于读取浮点数或复数类型
%s %v 用在字符串时会读取空白分隔的一个片段
flag '#'和'+' 未实现   
```

在无格式化verb或verb %v下扫描整数时会接受常用的进制设置前缀0（八进制）和0x（十六进制）。

宽度会在输入文本中被使用（%5s表示最多读取5个rune来生成一个字符串），但没有使用精度的语法（没有%5.2f，只有%5f）。

当使用格式字符串进行扫描时，多个连续的空白字符（除了换行符）在输出和输出中都被等价于一个空白符。在此前提下，格式字符串中的文本必须匹配输入的文本；如果不匹配扫描会中止，函数的整数返回值说明已经扫描并填写的参数个数。

在所有的扫描函数里，\r\n都被视为\n。

在所有的扫描函数里，如果一个操作数实现了Scan方法（或者说，它实现了Scanner接口），将会使用该接口为该操作数扫描文本。另外，如果如果扫描到（准备填写）的参数比提供的参数个数少，会返回一个错误。

提供的所有参数必须为指针或者实现了Scanner接口。注意：Fscan等函数可能会在返回前多读取一个rune，这导致多次调用这些函数时可能会跳过部分输入。只有在输入里各值之间没有空白时，会出现问题。如果提供给Fscan等函数的io.Reader接口实现了ReadRune方法，将使用该方法读取字符。如果该io.Reader接口还实现了UnreadRune方法，将是使用该方法保存字符，这样可以使成功执行的Fscan等函数不会丢失数据。如果要给一个没有这两个方法的io.Reader接口提供这两个方法，使用bufio.NewReader

### type [Stringer](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#63)

```go
type Stringer interface {
    String() string
}
```

实现了Stringer接口的类型（即有String方法），定义了该类型值的原始显示。当采用任何接受字符的verb（%v %s %q %x %X）动作格式化一个操作数时，或者被不使用格式字符串如Print函数打印操作数时，会调用String方法来生成输出的文本。

### type [GoStringer](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#71)

```go
type GoStringer interface {
    GoString() string
}
```

实现了GoStringer接口的类型（即有GoString方法），定义了该类型值的go语法表示。当采用verb %#v格式化一个操作数时，会调用GoString方法来生成输出的文本。

### type [State](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#39)

```go
type State interface {
    // Write方法用来写入格式化的文本
    Write(b []byte) (ret int, err error)
    // Width返回宽度值，及其是否被设置
    Width() (wid int, ok bool)
    // Precision返回精度值，及其是否被设置
    Precision() (prec int, ok bool)
    // Flag报告是否设置了flag c（一个字符，如+、-、#等）
    Flag(c int) bool
}
```

State代表一个传递给自定义Formatter接口的Format方法的打印环境。它实现了io.Writer接口用来写入格式化的文本，还提供了该操作数的格式字符串指定的选项和宽度、精度信息（通过调用方法）。

### type [Formatter](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#54)

```go
type Formatter interface {
    // c为verb，f提供verb的细节信息和Write方法用于写入生成的格式化文本
    Format(f State, c rune)
}
```

实现了Formatter接口的类型可以定制自己的格式化输出。Format方法的实现内部可以调用Sprint或Fprint等函数来生成自身的输出。

### type [ScanState](https://github.com/golang/go/blob/master/src/fmt/scan.go?name=release#29)

```go
type ScanState interface {
    // 从输入读取下一个rune（Unicode码值），在读取超过指定宽度时会返回EOF
    // 如果在Scanln、Fscanln或Sscanln中被调用，本方法会在返回第一个'\n'后再次调用时返回EOF
    ReadRune() (r rune, size int, err error)
    // UnreadRune方法让下一次调用ReadRune时返回上一次返回的rune且不移动读取位置
    UnreadRune() error
    // SkipSpace方法跳过输入中的空白，换行被视为空白
    // 在Scanln、Fscanln或Sscanln中被调用时，换行被视为EOF
    SkipSpace()
    // 方法从输入中依次读取rune并用f测试，直到f返回假；将读取的rune组织为一个[]byte切片返回。
    // 如果skipSpace参数为真，本方法会先跳过输入中的空白。
    // 如果f为nil，会使用!unicode.IsSpace(c)；就是说返回值token将为一串非空字符。
    // 换行被视为空白，在Scanln、Fscanln或Sscanln中被调用时，换行被视为EOF。
    // 返回的切片指向一个共享内存，可能被下一次调用Token方法时重写；
    // 或被使用该Scanstate的另一个Scan函数重写；或者在本次调用的Scan方法返回时重写。
    Token(skipSpace bool, f func(rune) bool) (token []byte, err error)
    // Width返回返回宽度值，及其是否被设置。单位是unicode码值。
    Width() (wid int, ok bool)
    // 因为本接口实现了ReadRune方法，Read方法永远不应被在Scanner接口中使用。
    // 一个合法的ScanStat接口实现可能会选择让本方法总是返回错误。
    Read(buf []byte) (n int, err error)
}
```

ScanState代表一个将传递给Scanner接口的Scan方法的扫描环境。 Scan函数中，可以进行一次一个rune的扫描，或者使用Token方法获得下一个token（比如空白分隔的token）。

### type [Scanner](https://github.com/golang/go/blob/master/src/fmt/scan.go?name=release#63)

```go
type Scanner interface {
    Scan(state ScanState, verb rune) error
}
```

当Scan、Scanf、Scanln或类似函数接受实现了Scanner接口的类型（其Scan方法的receiver必须是指针，该方法从输入读取该类型值的字符串表示并将结果写入receiver）作为参数时，会调用其Scan方法进行定制的扫描。

### func [Printf](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#196)

```go
func Printf(format string, a ...interface{}) (n int, err error)
```

Printf根据format参数生成格式化的字符串并写入标准输出。返回写入的字节数和遇到的任何错误。

### func [Fprintf](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#186)

```go
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
```

Fprintf根据format参数生成格式化的字符串并写入w。返回写入的字节数和遇到的任何错误。

### func [Sprintf](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#201)

```go
func Sprintf(format string, a ...interface{}) string
```

Sprintf根据format参数生成格式化的字符串并返回该字符串。

### func [Print](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#231)

```go
func Print(a ...interface{}) (n int, err error)
```

Print采用默认格式将其参数格式化并写入标准输出。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。返回写入的字节数和遇到的任何错误。

### func [Fprint](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#220)

```go
func Fprint(w io.Writer, a ...interface{}) (n int, err error)
```

Fprint采用默认格式将其参数格式化并写入w。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。返回写入的字节数和遇到的任何错误。

### func [Sprint](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#237)

```go
func Sprint(a ...interface{}) string
```

Sprint采用默认格式将其参数格式化，串联所有输出生成并返回一个字符串。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。

### func [Println](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#263)

```go
func Println(a ...interface{}) (n int, err error)
```

Println采用默认格式将其参数格式化并写入标准输出。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。返回写入的字节数和遇到的任何错误。

### func [Fprintln](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#252)

```go
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
```

Fprintln采用默认格式将其参数格式化并写入w。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。返回写入的字节数和遇到的任何错误。

### func [Sprintln](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#269)

```go
func Sprintln(a ...interface{}) string
```

Sprintln采用默认格式将其参数格式化，串联所有输出生成并返回一个字符串。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。

### func [Errorf](https://github.com/golang/go/blob/master/src/fmt/print.go?name=release#211)

```go
func Errorf(format string, a ...interface{}) error
```

Errorf根据format参数生成格式化字符串并返回一个包含该字符串的错误。

### func [Scanf](https://github.com/golang/go/blob/master/src/fmt/scan.go?name=release#84)

```go
func Scanf(format string, a ...interface{}) (n int, err error)
```

Scanf从标准输入扫描文本，根据format 参数指定的格式将成功读取的空白分隔的值保存进成功传递给本函数的参数。返回成功扫描的条目个数和遇到的任何错误。

### func [Fscanf](https://github.com/golang/go/blob/master/src/fmt/scan.go?name=release#143)

```go
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
```

Fscanf从r扫描文本，根据format 参数指定的格式将成功读取的空白分隔的值保存进成功传递给本函数的参数。返回成功扫描的条目个数和遇到的任何错误。

### func [Sscanf](https://github.com/golang/go/blob/master/src/fmt/scan.go?name=release#116)

```go
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
```

Sscanf从字符串str扫描文本，根据format 参数指定的格式将成功读取的空白分隔的值保存进成功传递给本函数的参数。返回成功扫描的条目个数和遇到的任何错误。

### func [Scan](https://github.com/golang/go/blob/master/src/fmt/scan.go?name=release#71)

```go
func Scan(a ...interface{}) (n int, err error)
```

Scan从标准输入扫描文本，将成功读取的空白分隔的值保存进成功传递给本函数的参数。换行视为空白。返回成功扫描的条目个数和遇到的任何错误。如果读取的条目比提供的参数少，会返回一个错误报告原因。

### func [Fscan](https://github.com/golang/go/blob/master/src/fmt/scan.go?name=release#124)

```go
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
```

Fscan从r扫描文本，将成功读取的空白分隔的值保存进成功传递给本函数的参数。换行视为空白。返回成功扫描的条目个数和遇到的任何错误。如果读取的条目比提供的参数少，会返回一个错误报告原因。

### func [Sscan](https://github.com/golang/go/blob/master/src/fmt/scan.go?name=release#103)

```go
func Sscan(str string, a ...interface{}) (n int, err error)
```

Sscan从字符串str扫描文本，将成功读取的空白分隔的值保存进成功传递给本函数的参数。换行视为空白。返回成功扫描的条目个数和遇到的任何错误。如果读取的条目比提供的参数少，会返回一个错误报告原因。

### func [Scanln](https://github.com/golang/go/blob/master/src/fmt/scan.go?name=release#77)

```go
func Scanln(a ...interface{}) (n int, err error)
```

Scanln类似Scan，但会在换行时才停止扫描。最后一个条目后必须有换行或者到达结束位置。

### func [Fscanln](https://github.com/golang/go/blob/master/src/fmt/scan.go?name=release#133)

```go
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
```

Fscanln类似Fscan，但会在换行时才停止扫描。最后一个条目后必须有换行或者到达结束位置。

### func [Sscanln](https://github.com/golang/go/blob/master/src/fmt/scan.go?name=release#109)

```go
func Sscanln(str string, a ...interface{}) (n int, err error)
```

Sscanln类似Sscan，但会在换行时才停止扫描。最后一个条目后必须有换行或者到达结束位置。

# strconv包

package strconv

```go
import "strconv"
```

strconv包实现了基本数据类型和其字符串表示的相互转换。

###  Constants

```go
const IntSize = intSize
```

IntSize是int或uint类型的字位数。

### Variables

```go
var ErrRange = errors.New("value out of range")
```

ErrRange表示超出目标类型表示范围。

```go
var ErrSyntax = errors.New("invalid syntax")
```

ErrSyntax表示不符合目标类型语法。

### type [NumError](https://github.com/golang/go/blob/master/src/strconv/atoi.go?name=release#16)

```go
type NumError struct {
    Func string // 失败的函数（ParseBool、ParseInt、ParseUint、ParseFloat）
    Num  string // 输入的字符串
    Err  error  // 失败的原因（ErrRange、ErrSyntax）
}
```

NumError表示一次失败的转换。

#### func (*NumError) [Error](https://github.com/golang/go/blob/master/src/strconv/atoi.go?name=release#22)

```go
func (e *NumError) Error() string
```

### func [IsPrint](https://github.com/golang/go/blob/master/src/strconv/quote.go?name=release#402)

```go
func IsPrint(r rune) bool
```

返回一个字符是否是可打印的，和unicode.IsPrint一样，r必须是：字母（广义）、数字、标点、符号、ASCII空格。

### func [CanBackquote](https://github.com/golang/go/blob/master/src/strconv/quote.go?name=release#145)

```go
func CanBackquote(s string) bool
```

返回字符串s是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串。

### func [Quote](https://github.com/golang/go/blob/master/src/strconv/quote.go?name=release#90)

```go
func Quote(s string) string
```

返回字符串s在go语法下的双引号字面值表示，控制字符、不可打印字符会进行转义。（如\t，\n，\xFF，\u0100）

### func [QuoteToASCII](https://github.com/golang/go/blob/master/src/strconv/quote.go?name=release#103)

```go
func QuoteToASCII(s string) string
```

返回字符串s在go语法下的双引号字面值表示，控制字符和不可打印字符、非ASCII字符会进行转义。

### func [QuoteRune](https://github.com/golang/go/blob/master/src/strconv/quote.go?name=release#116)

```go
func QuoteRune(r rune) string
```

返回字符r在go语法下的单引号字面值表示，控制字符、不可打印字符会进行转义。（如\t，\n，\xFF，\u0100）

### func [QuoteRuneToASCII](https://github.com/golang/go/blob/master/src/strconv/quote.go?name=release#131)

```go
func QuoteRuneToASCII(r rune) string
```

返回字符r在go语法下的单引号字面值表示，控制字符、不可打印字符、非ASCII字符会进行转义。

### func [Unquote](https://github.com/golang/go/blob/master/src/strconv/quote.go?name=release#294)

```go
func Unquote(s string) (t string, err error)
```

函数假设s是一个单引号、双引号、反引号包围的go语法字符串，解析它并返回它表示的值。（如果是单引号括起来的，函数会认为s是go字符字面值，返回一个单字符的字符串）

Example

```go
test := func(s string) {
    t, err := strconv.Unquote(s)
    if err != nil {
        fmt.Printf("Unquote(%#v): %v\n", s, err)
    } else {
        fmt.Printf("Unquote(%#v) = %v\n", s, t)
    }
}
s := `cafe\u0301`
// If the string doesn't have quotes, it can't be unquoted.
test(s) // invalid syntax
test("`" + s + "`")
test(`"` + s + `"`)
test(`'\u00e9'`)
```

Output:

```go
Unquote("cafe\\u0301"): invalid syntax
Unquote("`cafe\\u0301`") = cafe\u0301
Unquote("\"cafe\\u0301\"") = café
Unquote("'\\u00e9'") = é
```

### func [UnquoteChar](https://github.com/golang/go/blob/master/src/strconv/quote.go?name=release#182)

```go
func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error)
```

函数假设s是一个表示字符的go语法字符串，解析它并返回四个值：

```go
1) value，表示一个rune值或者一个byte值
2) multibyte，表示value是否是一个多字节的utf-8字符
3) tail，表示字符串剩余的部分
4) err，表示可能存在的语法错误
```

quote参数为单引号时，函数认为单引号是语法字符，不接受未转义的单引号；双引号时，函数认为双引号是语法字符，不接受未转义的双引号；如果是零值，函数把单引号和双引号当成普通字符。

### func [ParseBool](https://github.com/golang/go/blob/master/src/strconv/atob.go?name=release#10)

```go
func ParseBool(str string) (value bool, err error)
```

返回字符串表示的bool值。它接受1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误。

### func [ParseInt](https://github.com/golang/go/blob/master/src/strconv/atoi.go?name=release#150)

```go
func ParseInt(s string, base int, bitSize int) (i int64, err error)
```

返回字符串表示的整数值，接受正负号。

base指定进制（2到36），如果base为0，则会从字符串前置判断，"0x"是16进制，"0"是8进制，否则是10进制；

bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。

### func [ParseUint](https://github.com/golang/go/blob/master/src/strconv/atoi.go?name=release#48)

```go
func ParseUint(s string, base int, bitSize int) (n uint64, err error)
```

ParseUint类似ParseInt但不接受正负号，用于无符号整型。

### func [ParseFloat](https://github.com/golang/go/blob/master/src/strconv/atof.go?name=release#533)

```go
func ParseFloat(s string, bitSize int) (f float64, err error)
```

解析一个表示浮点数的字符串并返回其值。

如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64；返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。

### func [FormatBool](https://github.com/golang/go/blob/master/src/strconv/atob.go?name=release#21)

```go
func FormatBool(b bool) string
```

根据b的值返回"true"或"false"。

### func [FormatInt](https://github.com/golang/go/blob/master/src/strconv/itoa.go?name=release#18)

```go
func FormatInt(i int64, base int) string
```

返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母'a'到'z'表示大于10的数字。

### func [FormatUint](https://github.com/golang/go/blob/master/src/strconv/itoa.go?name=release#10)

```go
func FormatUint(i uint64, base int) string
```

是FormatInt的无符号整数版本。

### func [FormatFloat](https://github.com/golang/go/blob/master/src/strconv/ftoa.go?name=release#44)

```go
func FormatFloat(f float64, fmt byte, prec, bitSize int) string
```

函数将浮点数表示为字符串并返回。

bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。

fmt表示格式：'f'（-ddd.dddd）、'b'（-ddddp±ddd，指数为二进制）、'e'（-d.dddde±dd，十进制指数）、'E'（-d.ddddE±dd，十进制指数）、'g'（指数很大时用'e'格式，否则'f'格式）、'G'（指数很大时用'E'格式，否则'f'格式）。

prec控制精度（排除指数部分）：对'f'、'e'、'E'，它表示小数点后的数字个数；对'g'、'G'，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。

### func [Atoi](https://github.com/golang/go/blob/master/src/strconv/atoi.go?name=release#195)

```go
func Atoi(s string) (i int, err error)
```

Atoi是ParseInt(s, 10, 0)的简写。

### func [Itoa](https://github.com/golang/go/blob/master/src/strconv/itoa.go?name=release#24)

```go
func Itoa(i int) string
```

Itoa是FormatInt(i, 10) 的简写。

### func [AppendBool](https://github.com/golang/go/blob/master/src/strconv/atob.go?name=release#30)

```go
func AppendBool(dst []byte, b bool) []byte
```

等价于append(dst, FormatBool(b)...)

### func [AppendInt](https://github.com/golang/go/blob/master/src/strconv/itoa.go?name=release#30)

```go
func AppendInt(dst []byte, i int64, base int) []byte
```

等价于append(dst, FormatInt(I, base)...)

### func [AppendUint](https://github.com/golang/go/blob/master/src/strconv/itoa.go?name=release#37)

```go
func AppendUint(dst []byte, i uint64, base int) []byte
```

等价于append(dst, FormatUint(I, base)...)

### func [AppendFloat](https://github.com/golang/go/blob/master/src/strconv/ftoa.go?name=release#50)

```go
func AppendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int) []byte
```

等价于append(dst, FormatFloat(f, fmt, prec, bitSize)...)

### func [AppendQuote](https://github.com/golang/go/blob/master/src/strconv/quote.go?name=release#96)

```go
func AppendQuote(dst []byte, s string) []byte
```

等价于append(dst, Quote(s)...)

### func [AppendQuoteToASCII](https://github.com/golang/go/blob/master/src/strconv/quote.go?name=release#109)

```go
func AppendQuoteToASCII(dst []byte, s string) []byte
```

等价于append(dst, QuoteToASCII(s)...)

### func [AppendQuoteRune](https://github.com/golang/go/blob/master/src/strconv/quote.go?name=release#123)

```go
func AppendQuoteRune(dst []byte, r rune) []byte
```

等价于append(dst, QuoteRune(r)...)

### func [AppendQuoteRuneToASCII](https://github.com/golang/go/blob/master/src/strconv/quote.go?name=release#138)

```go
func AppendQuoteRuneToASCII(dst []byte, r rune) []byte
```

等价于append(dst, QuoteRuneToASCII(r)...)

# time包

package time

```go
import "time"
```

time包提供了时间的显示和测量用的函数。日历的计算采用的是公历。

### Constants

```go
const (
    ANSIC       = "Mon Jan _2 15:04:05 2006"
    UnixDate    = "Mon Jan _2 15:04:05 MST 2006"
    RubyDate    = "Mon Jan 02 15:04:05 -0700 2006"
    RFC822      = "02 Jan 06 15:04 MST"
    RFC822Z     = "02 Jan 06 15:04 -0700" // 使用数字表示时区的RFC822
    RFC850      = "Monday, 02-Jan-06 15:04:05 MST"
    RFC1123     = "Mon, 02 Jan 2006 15:04:05 MST"
    RFC1123Z    = "Mon, 02 Jan 2006 15:04:05 -0700" // 使用数字表示时区的RFC1123
    RFC3339     = "2006-01-02T15:04:05Z07:00"
    RFC3339Nano = "2006-01-02T15:04:05.999999999Z07:00"
    Kitchen     = "3:04PM"
    // 方便的时间戳
    Stamp      = "Jan _2 15:04:05"
    StampMilli = "Jan _2 15:04:05.000"
    StampMicro = "Jan _2 15:04:05.000000"
    StampNano  = "Jan _2 15:04:05.000000000"
)
```

这些预定义的版式用于Time.Format和Time.Parse函数。用在版式中的参考时间是：

```go
Mon Jan 2 15:04:05 MST 2006
```

对应的Unix时间是1136239445。因为MST的时区是GMT-0700，参考时间也可以表示为如下：

```go
01/02 03:04:05PM '06 -0700
```

要定义你自己的格式，写下该参考时间应用于你的格式的情况；例子请参见ANSIC、StampMicro或Kitchen等常数的值。该模型是为了演示参考时间的格式化效果，如此一来Format和Parse方法可以将相同的转换规则用于一个普通的时间值。

在格式字符串中，用前置的'0'表示一个可以被可以被数字替换的'0'（如果它后面的数字有两位）；使用下划线表示一个可以被数字替换的空格（如果它后面的数字有两位）；以便兼容Unix定长时间格式。

小数点后跟0到多个'0'，表示秒数的小数部分，输出时会生成和'0'一样多的小数位；小数点后跟0到多个'9'，表示秒数的小数部分，输出时会生成和'9'一样多的小数位但会将拖尾的'0'去掉。（只有）解析时，输入可以在秒字段后面紧跟一个小数部分，即使格式字符串里没有指明该部分。此时，小数点及其后全部的数字都会成为秒的小数部分。

数字表示的时区格式如下：

```go
-0700  ±hhmm
-07:00 ±hh:mm
```

将格式字符串中的负号替换为Z会触发ISO 8601行为（当时区是UTC时，输出Z而不是时区偏移量），这样：

```go
Z0700  Z or ±hhmm
Z07:00 Z or ±hh:mm
```

### type [ParseError](https://github.com/golang/go/blob/master/src/time/format.go?name=release#598)

```go
type ParseError struct {
    Layout     string
    Value      string
    LayoutElem string
    ValueElem  string
    Message    string
}
```

ParseError描述解析时间字符串时出现的错误。

#### func (*ParseError) [Error](https://github.com/golang/go/blob/master/src/time/format.go?name=release#611)

```go
func (e *ParseError) Error() string
```

Error返回ParseError的字符串表示。

### type [Weekday](https://github.com/golang/go/blob/master/src/time/time.go?name=release#115)

```go
type Weekday int
```

Weekday代表一周的某一天。

```go
const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
```

#### func (Weekday) [String](https://github.com/golang/go/blob/master/src/time/time.go?name=release#138)

```go
func (d Weekday) String() string
```

String返回该日（周几）的英文名（"Sunday"、"Monday"，……）

### type [Month](https://github.com/golang/go/blob/master/src/time/time.go?name=release#79)

```go
type Month int
```

Month代表一年的某个月。

```go
const (
    January Month = 1 + iota
    February
    March
    April
    May
    June
    July
    August
    September
    October
    November
    December
)
```

Example

```go
_, month, day := time.Now().Date()
if month == time.November && day == 10 {
    fmt.Println("Happy Go day!")
}
```

#### func (Month) [String](https://github.com/golang/go/blob/master/src/time/time.go?name=release#112)

```go
func (m Month) String() string
```

String返回月份的英文名（"January"，"February"，……）

### type [Location](https://github.com/golang/go/blob/master/src/time/zoneinfo.go?name=release#15)

```go
type Location struct {
    // 内含隐藏或非导出字段
}
```

Location代表一个（关联到某个时间点的）地点，以及该地点所在的时区。

```go
var Local *Location = &localLoc
```

Local代表系统本地，对应本地时区。

```go
var UTC *Location = &utcLoc
```

UTC代表通用协调时间，对应零时区。

#### func [LoadLocation](https://github.com/golang/go/blob/master/src/time/zoneinfo.go?name=release#273)

```go
func LoadLocation(name string) (*Location, error)
```

LoadLocation返回使用给定的名字创建的Location。

如果name是""或"UTC"，返回UTC；如果name是"Local"，返回Local；否则name应该是IANA时区数据库里有记录的地点名（该数据库记录了地点和对应的时区），如"America/New_York"。

LoadLocation函数需要的时区数据库可能不是所有系统都提供，特别是非Unix系统。此时LoadLocation会查找环境变量ZONEINFO指定目录或解压该变量指定的zip文件（如果有该环境变量）；然后查找Unix系统的惯例时区数据安装位置，最后查找$GOROOT/lib/time/zoneinfo.zip。

#### func [FixedZone](https://github.com/golang/go/blob/master/src/time/zoneinfo.go?name=release#89)

```go
func FixedZone(name string, offset int) *Location
```

FixedZone使用给定的地点名name和时间偏移量offset（单位秒）创建并返回一个Location

#### func (*Location) [String](https://github.com/golang/go/blob/master/src/time/zoneinfo.go?name=release#83)

```go
func (l *Location) String() string
```

String返回对时区信息的描述，返回值绑定为LoadLocation或FixedZone函数创建l时的name参数。

### type [Time](https://github.com/golang/go/blob/master/src/time/time.go?name=release#34)

```go
type Time struct {
    // 内含隐藏或非导出字段
}
```

Time代表一个纳秒精度的时间点。

程序中应使用Time类型值来保存和传递时间，而不能用指针。就是说，表示时间的变量和字段，应为time.Time类型，而不是*time.Time.类型。一个Time类型值可以被多个go程同时使用。时间点可以使用Before、After和Equal方法进行比较。Sub方法让两个时间点相减，生成一个Duration类型值（代表时间段）。Add方法给一个时间点加上一个时间段，生成一个新的Time类型时间点。

Time零值代表时间点January 1, year 1, 00:00:00.000000000 UTC。因为本时间点一般不会出现在使用中，IsZero方法提供了检验时间是否显式初始化的一个简单途径。

每一个时间都具有一个地点信息（及对应地点的时区信息），当计算时间的表示格式时，如Format、Hour和Year等方法，都会考虑该信息。Local、UTC和In方法返回一个指定时区（但指向同一时间点）的Time。修改地点/时区信息只是会改变其表示；不会修改被表示的时间点，因此也不会影响其计算。

#### func [Date](https://github.com/golang/go/blob/master/src/time/time.go?name=release#1022)

```go
func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time
```

Date返回一个时区为loc、当地时间为：

```go
year-month-day hour:min:sec + nsec nanoseconds
```

的时间点。

month、day、hour、min、sec和nsec的值可能会超出它们的正常范围，在转换前函数会自动将之规范化。如October 32被修正为November 1。

夏时制的时区切换会跳过或重复时间。如，在美国，March 13, 2011 2:15am从来不会出现，而November 6, 2011 1:15am 会出现两次。此时，时区的选择和时间是没有良好定义的。Date会返回在时区切换的两个时区其中一个时区

正确的时间，但本函数不会保证在哪一个时区正确。

如果loc为nil会panic。

Example

```go
t := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
fmt.Printf("Go launched at %s\n", t.Local())
```

Output:

```go
Go launched at 2009-11-10 15:00:00 -0800 PST
```

#### func [Now](https://github.com/golang/go/blob/master/src/time/time.go?name=release#784)

```go
func Now() Time
```

Now返回当前本地时间。

#### func [Parse](https://github.com/golang/go/blob/master/src/time/format.go?name=release#711)

```go
func Parse(layout, value string) (Time, error)
```

Parse解析一个格式化的时间字符串并返回它代表的时间。layout定义了参考时间：

```go
Mon Jan 2 15:04:05 -0700 MST 2006
```

在输入格式下的字符串表示，作为输入的格式的示例。同样的格式规则会被用于输入字符串。

预定义的ANSIC、UnixDate、RFC3339和其他版式描述了参考时间的标准或便捷表示。要获得更多参考时间的定义和格式，参见本包的ANSIC和其他版式常量。

value中漏掉的元素会被视为0；如果不能是0，会被视为1。因此，解析"3:04pm"会返回对应时间点：Jan 1, year 0, 15:04:00 UTC的Time（注意因为year为0，该时间在Time零值之前）。年份必须在0000..9999范围内。周几会被检查其语法，但是会被忽略。

如果缺少表示时区的信息，Parse会将时区设置为UTC。

当解析具有时区偏移量的时间字符串时，如果该时区偏移量和本地时区相同，Parse会在返回值中将Location设置为本地和本地时区。否则，它会将Location设置为一个虚构的具有该时区偏移量的值。

当解析具有时区缩写的时间字符串时，如果该时区缩写具有已定义的时间偏移量，会使用该偏移量。如果时区缩写是"UTC"，会将该时间视为UTC时间，不考虑Location。如果时区缩写是未知的，Parse会将Location设置为一个虚构的地点为时区缩写，时间偏移量为0的值。这种做法是为了让一个时间可以在同一版式下不丢失信息的被解析和重新格式化；但字符串表示和具体表示的时间点会因为实际时区偏移量而不同。为了避免这些问题，请使用数字表示的时区偏移量，或者使用ParseInLocation函数。

Example

```go
// longForm shows by example how the reference time would be represented in
// the desired layout.
const longForm = "Jan 2, 2006 at 3:04pm (MST)"
t, _ := time.Parse(longForm, "Feb 3, 2013 at 7:54pm (PST)")
fmt.Println(t)
// shortForm is another way the reference time would be represented
// in the desired layout; it has no time zone present.
// Note: without explicit zone, returns time in UTC.
const shortForm = "2006-Jan-02"
t, _ = time.Parse(shortForm, "2013-Feb-03")
fmt.Println(t)
```

Output:

```go
2013-02-03 19:54:00 -0800 PST
2013-02-03 00:00:00 +0000 UTC
```

#### func [ParseInLocation](https://github.com/golang/go/blob/master/src/time/format.go?name=release#720)

```go
func ParseInLocation(layout, value string, loc *Location) (Time, error)
```

ParseInLocation类似Parse但有两个重要的不同之处。第一，当缺少时区信息时，Parse将时间解释为UTC时间，而ParseInLocation将返回值的Location设置为loc；第二，当时间字符串提供了时区偏移量信息时，Parse会尝试去匹配本地时区，而ParseInLocation会去匹配loc。

Example

```go
loc, _ := time.LoadLocation("Europe/Berlin")
const longForm = "Jan 2, 2006 at 3:04pm (MST)"
t, _ := time.ParseInLocation(longForm, "Jul 9, 2012 at 5:02am (CEST)", loc)
fmt.Println(t)
// Note: without explicit zone, returns time in given location.
const shortForm = "2006-Jan-02"
t, _ = time.ParseInLocation(shortForm, "2012-Jul-09", loc)
fmt.Println(t)
```

Output:

```
2012-07-09 05:02:00 +0200 CEST
2012-07-09 00:00:00 +0200 CEST
```

#### func [Unix](https://github.com/golang/go/blob/master/src/time/time.go?name=release#972)

```go
func Unix(sec int64, nsec int64) Time
```

Unix创建一个本地时间，对应sec和nsec表示的Unix时间（从January 1, 1970 UTC至该时间的秒数和纳秒数）。

nsec的值在[0, 999999999]范围外是合法的。

#### func (Time) [Location](https://github.com/golang/go/blob/master/src/time/time.go?name=release#813)

```go
func (t Time) Location() *Location
```

Location返回t的地点和时区信息。

#### func (Time) [Zone](https://github.com/golang/go/blob/master/src/time/time.go?name=release#823)

```go
func (t Time) Zone() (name string, offset int)
```

Zone计算t所在的时区，返回该时区的规范名（如"CET"）和该时区相对于UTC的时间偏移量（单位秒）。

#### func (Time) [IsZero](https://github.com/golang/go/blob/master/src/time/time.go?name=release#243)

```go
func (t Time) IsZero() bool
```

IsZero报告t是否代表Time零值的时间点，January 1, year 1, 00:00:00 UTC。

#### func (Time) [Local](https://github.com/golang/go/blob/master/src/time/time.go?name=release#796)

```go
func (t Time) Local() Time
```

Local返回采用本地和本地时区，但指向同一时间点的Time。

#### func (Time) [UTC](https://github.com/golang/go/blob/master/src/time/time.go?name=release#790)

```go
func (t Time) UTC() Time
```

UTC返回采用UTC和零时区，但指向同一时间点的Time。

#### func (Time) [In](https://github.com/golang/go/blob/master/src/time/time.go?name=release#804)

```go
func (t Time) In(loc *Location) Time
```

In返回采用loc指定的地点和时区，但指向同一时间点的Time。如果loc为nil会panic。

#### func (Time) [Unix](https://github.com/golang/go/blob/master/src/time/time.go?name=release#830)

```go
func (t Time) Unix() int64
```

Unix将t表示为Unix时间，即从时间点January 1, 1970 UTC到时间点t所经过的时间（单位秒）。

#### func (Time) [UnixNano](https://github.com/golang/go/blob/master/src/time/time.go?name=release#838)

```go
func (t Time) UnixNano() int64
```

UnixNano将t表示为Unix时间，即从时间点January 1, 1970 UTC到时间点t所经过的时间（单位纳秒）。如果纳秒为单位的unix时间超出了int64能表示的范围，结果是未定义的。注意这就意味着Time零值调用UnixNano方法的话，结果是未定义的。

#### func (Time) [Equal](https://github.com/golang/go/blob/master/src/time/time.go?name=release#74)

```go
func (t Time) Equal(u Time) bool
```

判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。本方法和用t==u不同，这种方法还会比较地点和时区信息。

#### func (Time) [Before](https://github.com/golang/go/blob/master/src/time/time.go?name=release#65)

```go
func (t Time) Before(u Time) bool
```

如果t代表的时间点在u之前，返回真；否则返回假。

#### func (Time) [After](https://github.com/golang/go/blob/master/src/time/time.go?name=release#60)

```go
func (t Time) After(u Time) bool
```

如果t代表的时间点在u之后，返回真；否则返回假。

#### func (Time) [Date](https://github.com/golang/go/blob/master/src/time/time.go?name=release#292)

```go
func (t Time) Date() (year int, month Month, day int)
```

返回时间点t对应的年、月、日。

#### func (Time) [Clock](https://github.com/golang/go/blob/master/src/time/time.go?name=release#387)

```go
func (t Time) Clock() (hour, min, sec int)
```

返回t对应的那一天的时、分、秒。

#### func (Time) [Year](https://github.com/golang/go/blob/master/src/time/time.go?name=release#298)

```go
func (t Time) Year() int
```

返回时间点t对应的年份。

#### func (Time) [Month](https://github.com/golang/go/blob/master/src/time/time.go?name=release#304)

```go
func (t Time) Month() Month
```

返回时间点t对应那一年的第几月。

#### func (Time) [ISOWeek](https://github.com/golang/go/blob/master/src/time/time.go?name=release#331)

```go
func (t Time) ISOWeek() (year, week int)
```

返回时间点t对应的ISO 9601标准下的年份和星期编号。星期编号范围[1,53]，1月1号到1月3号可能属于上一年的最后一周，12月29号到12月31号可能属于下一年的第一周。

#### func (Time) [YearDay](https://github.com/golang/go/blob/master/src/time/time.go?name=release#424)

```go
func (t Time) YearDay() int
```

返回时间点t对应的那一年的第几天，平年的返回值范围[1,365]，闰年[1,366]。

#### func (Time) [Day](https://github.com/golang/go/blob/master/src/time/time.go?name=release#310)

```go
func (t Time) Day() int
```

返回时间点t对应那一月的第几日。

#### func (Time) [Weekday](https://github.com/golang/go/blob/master/src/time/time.go?name=release#316)

```go
func (t Time) Weekday() Weekday
```

返回时间点t对应的那一周的周几。

#### func (Time) [Hour](https://github.com/golang/go/blob/master/src/time/time.go?name=release#402)

```go
func (t Time) Hour() int
```

返回t对应的那一天的第几小时，范围[0, 23]。

#### func (Time) [Minute](https://github.com/golang/go/blob/master/src/time/time.go?name=release#407)

```go
func (t Time) Minute() int
```

返回t对应的那一小时的第几分种，范围[0, 59]。

#### func (Time) [Second](https://github.com/golang/go/blob/master/src/time/time.go?name=release#412)

```go
func (t Time) Second() int
```

返回t对应的那一分钟的第几秒，范围[0, 59]。

#### func (Time) [Nanosecond](https://github.com/golang/go/blob/master/src/time/time.go?name=release#418)

```go
func (t Time) Nanosecond() int
```

返回t对应的那一秒内的纳秒偏移量，范围[0, 999999999]。

#### func (Time) [Add](https://github.com/golang/go/blob/master/src/time/time.go?name=release#613)

```go
func (t Time) Add(d Duration) Time
```

Add返回时间点t+d。

#### func (Time) [AddDate](https://github.com/golang/go/blob/master/src/time/time.go?name=release#658)

```go
func (t Time) AddDate(years int, months int, days int) Time
```

AddDate返回增加了给出的年份、月份和天数的时间点Time。例如，时间点January 1, 2011调用AddDate(-1, 2, 3)会返回March 4, 2010。

AddDate会将结果规范化，类似Date函数的做法。因此，举个例子，给时间点October 31添加一个月，会生成时间点December 1。（从时间点November 31规范化而来）

#### func (Time) [Sub](https://github.com/golang/go/blob/master/src/time/time.go?name=release#631)

```go
func (t Time) Sub(u Time) Duration
```

返回一个时间段t-u。如果结果超出了Duration可以表示的最大值/最小值，将返回最大值/最小值。要获取时间点t-d（d为Duration），可以使用t.Add(-d)。

#### func (Time) [Round](https://github.com/golang/go/blob/master/src/time/time.go?name=release#1107)

```go
func (t Time) Round(d Duration) Time
```

返回距离t最近的时间点，该时间点应该满足从Time零值到该时间点的时间段能整除d；如果有两个满足要求的时间点，距离t相同，会向上舍入；如果d <= 0，会返回t的拷贝。

Example

```go
t := time.Date(0, 0, 0, 12, 15, 30, 918273645, time.UTC)
round := []time.Duration{
    time.Nanosecond,
    time.Microsecond,
    time.Millisecond,
    time.Second,
    2 * time.Second,
    time.Minute,
    10 * time.Minute,
    time.Hour,
}
for _, d := range round {
    fmt.Printf("t.Round(%6s) = %s\n", d, t.Round(d).Format("15:04:05.999999999"))
}
```

Output:

```go
t.Round(   1ns) = 12:15:30.918273645
t.Round(   1us) = 12:15:30.918274
t.Round(   1ms) = 12:15:30.918
t.Round(    1s) = 12:15:31
t.Round(    2s) = 12:15:30
t.Round(  1m0s) = 12:16:00
t.Round( 10m0s) = 12:20:00
t.Round(1h0m0s) = 12:00:00
```

#### func (Time) [Truncate](https://github.com/golang/go/blob/master/src/time/time.go?name=release#1096)

```go
func (t Time) Truncate(d Duration) Time
```

类似Round，但是返回的是最接近但早于t的时间点；如果d <= 0，会返回t的拷贝。

Example

```go
t, _ := time.Parse("2006 Jan 02 15:04:05", "2012 Dec 07 12:15:30.918273645")
trunc := []time.Duration{
    time.Nanosecond,
    time.Microsecond,
    time.Millisecond,
    time.Second,
    2 * time.Second,
    time.Minute,
    10 * time.Minute,
    time.Hour,
}
for _, d := range trunc {
    fmt.Printf("t.Truncate(%6s) = %s\n", d, t.Truncate(d).Format("15:04:05.999999999"))
}
```

Output:

```go
t.Truncate(   1ns) = 12:15:30.918273645
t.Truncate(   1us) = 12:15:30.918273
t.Truncate(   1ms) = 12:15:30.918
t.Truncate(    1s) = 12:15:30
t.Truncate(    2s) = 12:15:30
t.Truncate(  1m0s) = 12:15:00
t.Truncate( 10m0s) = 12:10:00
t.Truncate(1h0m0s) = 12:00:00
```

#### func (Time) [Format](https://github.com/golang/go/blob/master/src/time/format.go?name=release#414)

```go
func (t Time) Format(layout string) string
```

Format根据layout指定的格式返回t代表的时间点的格式化文本表示。layout定义了参考时间：

```go
Mon Jan 2 15:04:05 -0700 MST 2006
```

格式化后的字符串表示，它作为期望输出的例子。同样的格式规则会被用于格式化时间。

预定义的ANSIC、UnixDate、RFC3339和其他版式描述了参考时间的标准或便捷表示。要获得更多参考时间的定义和格式，参见本包的ANSIC和其他版式常量。

Example

```go
// layout shows by example how the reference time should be represented.
const layout = "Jan 2, 2006 at 3:04pm (MST)"
t := time.Date(2009, time.November, 10, 15, 0, 0, 0, time.Local)
fmt.Println(t.Format(layout))
fmt.Println(t.UTC().Format(layout))
```

Output:

```
Nov 10, 2009 at 3:00pm (PST)
Nov 10, 2009 at 11:00pm (UTC)
```

#### func (Time) [String](https://github.com/golang/go/blob/master/src/time/format.go?name=release#399)

```go
func (t Time) String() string
```

String返回采用如下格式字符串的格式化时间。

```go
"2006-01-02 15:04:05.999999999 -0700 MST"
```

#### func (Time) [GobEncode](https://github.com/golang/go/blob/master/src/time/time.go?name=release#924)

```go
func (t Time) GobEncode() ([]byte, error)
```

GobEncode实现了gob.GobEncoder接口。

#### func (*Time) [GobDecode](https://github.com/golang/go/blob/master/src/time/time.go?name=release#929)

```go
func (t *Time) GobDecode(data []byte) error
```

GobEncode实现了gob.GobDecoder接口。

#### func (Time) [MarshalBinary](https://github.com/golang/go/blob/master/src/time/time.go?name=release#845)

```go
func (t Time) MarshalBinary() ([]byte, error)
```

MarshalBinary实现了encoding.BinaryMarshaler接口。

#### func (*Time) [UnmarshalBinary](https://github.com/golang/go/blob/master/src/time/time.go?name=release#884)

```go
func (t *Time) UnmarshalBinary(data []byte) error
```

UnmarshalBinary实现了encoding.BinaryUnmarshaler接口。

#### func (Time) [MarshalJSON](https://github.com/golang/go/blob/master/src/time/time.go?name=release#935)

```go
func (t Time) MarshalJSON() ([]byte, error)
```

MarshalJSON实现了json.Marshaler接口。返回值是用双引号括起来的采用[RFC 3339](http://tools.ietf.org/html/rfc3339)格式进行格式化的时间表示，如果需要会提供小于秒的精度。

#### func (*Time) [UnmarshalJSON](https://github.com/golang/go/blob/master/src/time/time.go?name=release#946)

```go
func (t *Time) UnmarshalJSON(data []byte) (err error)
```

UnmarshalJSON实现了json.Unmarshaler接口。时间被期望是双引号括起来的[RFC 3339](http://tools.ietf.org/html/rfc3339)格式。

#### func (Time) [MarshalText](https://github.com/golang/go/blob/master/src/time/time.go?name=release#954)

```go
func (t Time) MarshalText() ([]byte, error)
```

MarshalText实现了encoding.TextMarshaler接口。返回值是采用[RFC 3339](http://tools.ietf.org/html/rfc3339)格式进行格式化的时间表示，如果需要会提供小于秒的精度。

#### func (*Time) [UnmarshalText](https://github.com/golang/go/blob/master/src/time/time.go?name=release#963)

```go
func (t *Time) UnmarshalText(data []byte) (err error)
```

UnmarshalText实现了encoding.TextUnmarshaler接口。时间被期望采用[RFC 3339](http://tools.ietf.org/html/rfc3339)格式。

### type [Duration](https://github.com/golang/go/blob/master/src/time/time.go?name=release#432)

```go
type Duration int64
```

Duration类型代表两个时间点之间经过的时间，以纳秒为单位。可表示的最长时间段大约290年。

```go
const (
    Nanosecond  Duration = 1
    Microsecond          = 1000 * Nanosecond
    Millisecond          = 1000 * Microsecond
    Second               = 1000 * Millisecond
    Minute               = 60 * Second
    Hour                 = 60 * Minute
)
```

常用的时间段。没有定义一天或超过一天的单元，以避免夏时制的时区切换的混乱。

要将Duration类型值表示为某时间单元的个数，用除法：

```go
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
```

要将整数个某时间单元表示为Duration类型值，用乘法：

```go
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
```

Example

```go
t0 := time.Now()
expensiveCall()
t1 := time.Now()
fmt.Printf("The call took %v to run.\n", t1.Sub(t0))
```

#### func [ParseDuration](https://github.com/golang/go/blob/master/src/time/format.go?name=release#1158)

```go
func ParseDuration(s string) (Duration, error)
```

ParseDuration解析一个时间段字符串。一个时间段字符串是一个序列，每个片段包含可选的正负号、十进制数、可选的小数部分和单位后缀，如"300ms"、"-1.5h"、"2h45m"。合法的单位有"ns"、"us" /"µs"、"ms"、"s"、"m"、"h"。

#### func [Since](https://github.com/golang/go/blob/master/src/time/time.go?name=release#646)

```go
func Since(t Time) Duration
```

Since返回从t到现在经过的时间，等价于time.Now().Sub(t)。

#### func (Duration) [Hours](https://github.com/golang/go/blob/master/src/time/time.go?name=release#606)

```go
func (d Duration) Hours() float64
```

Hours将时间段表示为float64类型的小时数。

#### func (Duration) [Minutes](https://github.com/golang/go/blob/master/src/time/time.go?name=release#599)

```go
func (d Duration) Minutes() float64
```

Hours将时间段表示为float64类型的分钟数。

#### func (Duration) [Seconds](https://github.com/golang/go/blob/master/src/time/time.go?name=release#592)

```go
func (d Duration) Seconds() float64
```

Hours将时间段表示为float64类型的秒数。

#### func (Duration) [Nanoseconds](https://github.com/golang/go/blob/master/src/time/time.go?name=release#580)

```go
func (d Duration) Nanoseconds() int64
```

Hours将时间段表示为int64类型的纳秒数，等价于int64(d)。

#### func (Duration) [String](https://github.com/golang/go/blob/master/src/time/time.go?name=release#464)

```go
func (d Duration) String() string
```

返回时间段采用"72h3m0.5s"格式的字符串表示。最前面可以有符号，数字+单位为一个单元，开始部分的0值单元会被省略；如果时间段<1s，会使用"ms"、"us"、"ns"来保证第一个单元的数字不是0；如果时间段为0，会返回"0"。

### type [Timer](https://github.com/golang/go/blob/master/src/time/sleep.go?name=release#45)

```go
type Timer struct {
    C <-chan Time
    // 内含隐藏或非导出字段
}
```

Timer类型代表单次时间事件。当Timer到期时，当时的时间会被发送给C，除非Timer是被AfterFunc函数创建的。

#### func [NewTimer](https://github.com/golang/go/blob/master/src/time/sleep.go?name=release#61)

```go
func NewTimer(d Duration) *Timer
```

NewTimer创建一个Timer，它会在最少过去时间段d后到期，向其自身的C字段发送当时的时间。

#### func [AfterFunc](https://github.com/golang/go/blob/master/src/time/sleep.go?name=release#108)

```go
func AfterFunc(d Duration, f func()) *Timer
```

AfterFunc另起一个go程等待时间段d过去，然后调用f。它返回一个Timer，可以通过调用其Stop方法来取消等待和对f的调用。

#### func (*Timer) [Reset](https://github.com/golang/go/blob/master/src/time/sleep.go?name=release#78)

```go
func (t *Timer) Reset(d Duration) bool
```

Reset使t重新开始计时，（本方法返回后再）等待时间段d过去后到期。如果调用时t还在等待中会返回真；如果t已经到期或者被停止了会返回假。

#### func (*Timer) [Stop](https://github.com/golang/go/blob/master/src/time/sleep.go?name=release#55)

```go
func (t *Timer) Stop() bool
```

Stop停止Timer的执行。如果停止了t会返回真；如果t已经被停止或者过期了会返回假。Stop不会关闭通道t.C，以避免从该通道的读取不正确的成功。

### type [Ticker](https://github.com/golang/go/blob/master/src/time/tick.go?name=release#11)

```go
type Ticker struct {
    C <-chan Time // 周期性传递时间信息的通道
    // 内含隐藏或非导出字段
}
```

Ticker保管一个通道，并每隔一段时间向其传递"tick"。

#### func [NewTicker](https://github.com/golang/go/blob/master/src/time/tick.go?name=release#21)

```go
func NewTicker(d Duration) *Ticker
```

NewTicker返回一个新的Ticker，该Ticker包含一个通道字段，并会每隔时间段d就向该通道发送当时的时间。它会调整时间间隔或者丢弃tick信息以适应反应慢的接收者。如果d<=0会panic。关闭该Ticker可以释放相关资源。

#### func (*Ticker) [Stop](https://github.com/golang/go/blob/master/src/time/tick.go?name=release#45)

```go
func (t *Ticker) Stop()
```

Stop关闭一个Ticker。在关闭后，将不会发送更多的tick信息。Stop不会关闭通道t.C，以避免从该通道的读取不正确的成功。

### func [Sleep](https://github.com/golang/go/blob/master/src/time/sleep.go?name=release#9)

```go
func Sleep(d Duration)
```

Sleep阻塞当前go程至少d代表的时间段。d<=0时，Sleep会立刻返回。

Example

```go
time.Sleep(100 * time.Millisecond)
```

### func [After](https://github.com/golang/go/blob/master/src/time/sleep.go?name=release#101)

```go
func After(d Duration) <-chan Time
```

After会在另一线程经过时间段d后向返回值发送当时的时间。等价于NewTimer(d).C。

Example

```go
select {
case m := <-c:
    handle(m)
case <-time.After(5 * time.Minute):
    fmt.Println("timed out")
}
```

### func [Tick](https://github.com/golang/go/blob/master/src/time/tick.go?name=release#51)

```go
func Tick(d Duration) <-chan Time
```

Tick是NewTicker的封装，只提供对Ticker的通道的访问。如果不需要关闭Ticker，本函数就很方便。

Example

```go
c := time.Tick(1 * time.Minute)
for now := range c {
    fmt.Printf("%v %s\n", now, statusUpdate())
}
```

# path/filepath包

package filepath

```go
import "path/filepath"
```

filepath包实现了兼容各操作系统的文件路径的实用操作函数。

### Constants

```go
const (
    Separator     = os.PathSeparator
    ListSeparator = os.PathListSeparator
)
```

### Variables

```go
var ErrBadPattern = errors.New("syntax error in pattern")
```

ErrBadPattern表示一个glob模式匹配字符串的格式错误。

```go
var SkipDir = errors.New("skip this directory")
```

用作WalkFunc类型的返回值，表示该次调用的path参数指定的目录应被跳过。本错误不应被任何其他函数返回。

### func [IsAbs](https://github.com/golang/go/blob/master/src/path/filepath/path_unix.go?name=release#12)

```go
func IsAbs(path string) bool
```

IsAbs返回路径是否是一个绝对路径。

### func [Abs](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#233)

```go
func Abs(path string) (string, error)
```

Abs函数返回path代表的绝对路径，如果path不是绝对路径，会加入当前工作目录以使之成为绝对路径。因为硬链接的存在，不能保证返回的绝对路径是唯一指向该地址的绝对路径。

### func [Rel](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#251)

```go
func Rel(basepath, targpath string) (string, error)
```

Rel函数返回一个相对路径，将basepath和该路径用路径分隔符连起来的新路径在词法上等价于targpath。也就是说，Join(basepath, Rel(basepath, targpath))等价于targpath本身。如果成功执行，返回值总是相对于basepath的，即使basepath和targpath没有共享的路径元素。如果两个参数一个是相对路径而另一个是绝对路径，或者targpath无法表示为相对于basepath的路径，将返回错误。

Example

```go
paths := []string{
    "/a/b/c",
    "/b/c",
    "./b/c",
}
base := "/a"
fmt.Println("On Unix:")
for _, p := range paths {
    rel, err := filepath.Rel(base, p)
    fmt.Printf("%q: %q %v\n", p, rel, err)
}
```

Output:

```go
On Unix:
"/a/b/c": "b/c" <nil>
"/b/c": "../b/c" <nil>
"./b/c": "" Rel: can't make b/c relative to /a
```

### func [SplitList](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#178)

```go
func SplitList(path string) []string
```

将PATH或GOPATH等环境变量里的多个路径分割开（这些路径被OS特定的表分隔符连接起来）。与strings.Split函数的不同之处是：对""，SplitList返回[]string{}，而strings.Split返回[]string{""}。

Example

```go
fmt.Println("On Unix:", filepath.SplitList("/a/b/c:/usr/bin"))
```

Output:

```go
On Unix: [/a/b/c /usr/bin]
```

### func [Split](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#187)

```go
func Split(path string) (dir, file string)
```

Split函数将路径从最后一个路径分隔符后面位置分隔为两个部分（dir和file）并返回。如果路径中没有路径分隔符，函数返回值dir会设为空字符串，file会设为path。两个返回值满足path == dir+file。

### func [Join](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#199)

```go
func Join(elem ...string) string
```

Join函数可以将任意数量的路径元素放入一个单一路径里，会根据需要添加路径分隔符。结果是经过简化的，所有的空字符串元素会被忽略。

### func [FromSlash](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#168)

```go
func FromSlash(path string) string
```

FromSlash函数将path中的斜杠（'/'）替换为路径分隔符并返回替换结果，多个斜杠会替换为多个路径分隔符。

### func [ToSlash](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#158)

```go
func ToSlash(path string) string
```

ToSlash函数将path中的路径分隔符替换为斜杠（'/'）并返回替换结果，多个路径分隔符会替换为多个斜杠。

### func [VolumeName](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#465)

```go
func VolumeName(path string) (v string)
```

VolumeName函数返回最前面的卷名。如Windows系统里提供参数"C:\foo\bar"会返回"C:"；Unix/linux系统的"\\host\share\foo"会返回"\\host\share"；其他平台会返回""。

### func [Dir](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#444)

```go
func Dir(path string) string
```

Dir返回路径除去最后一个路径元素的部分，即该路径最后一个元素所在的目录。在使用Split去掉最后一个元素后，会简化路径并去掉末尾的斜杠。如果路径是空字符串，会返回"."；如果路径由1到多个路径分隔符后跟0到多个非路径分隔符字符组成，会返回单个路径分隔符；其他任何情况下都不会返回以路径分隔符结尾的路径。

### func [Base](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#413)

```go
func Base(path string) string
```

Base函数返回路径的最后一个元素。在提取元素前会求掉末尾的路径分隔符。如果路径是""，会返回"."；如果路径是只有一个斜杆构成，会返回单个路径分隔符。

### func [Ext](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#212)

```go
func Ext(path string) string
```

Ext函数返回path文件扩展名。返回值是路径最后一个路径元素的最后一个'.'起始的后缀（包括'.'）。如果该元素没有'.'会返回空字符串。

### func [Clean](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#81)

```go
func Clean(path string) string
```

Clean函数通过单纯的词法操作返回和path代表同一地址的最短路径。

它会不断的依次应用如下的规则，直到不能再进行任何处理：

```go
1. 将连续的多个路径分隔符替换为单个路径分隔符
2. 剔除每一个.路径名元素（代表当前目录）
3. 剔除每一个路径内的..路径名元素（代表父目录）和它前面的非..路径名元素
4. 剔除开始一个根路径的..路径名元素，即将路径开始处的"/.."替换为"/"（假设路径分隔符是'/'）
```

返回的路径只有其代表一个根地址时才以路径分隔符结尾，如Unix的"/"或Windows的`C:\`。

如果处理的结果是空字符串，Clean会返回"."。参见<http://plan9.bell-labs.com/sys/doc/lexnames.html>

### func [EvalSymlinks](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#225)

```go
func EvalSymlinks(path string) (string, error)
```

EvalSymlinks函数返回path指向的符号链接（软链接）所包含的路径。如果path和返回值都是相对路径，会相对于当前目录；除非两个路径其中一个是绝对路径。

### func [Match](https://github.com/golang/go/blob/master/src/path/filepath/match.go?name=release#44)

```go
func Match(pattern, name string) (matched bool, err error)
```

Match returns true if name matches the shell file name pattern. The pattern syntax is:

```go
pattern:
	{ term }
term:
	'*'                                  匹配0或多个非路径分隔符的字符
	'?'                                  匹配1个非路径分隔符的字符
	'[' [ '^' ] { character-range } ']'  字符组（必须非空）
	c                                    匹配字符c（c != '*', '?', '\\', '['）
	'\\' c                               匹配字符c
character-range:
	c           匹配字符c（c != '\\', '-', ']'）
	'\\' c      匹配字符c
	lo '-' hi   匹配区间[lo, hi]内的字符
```

Match要求匹配整个name字符串，而不是它的一部分。只有pattern语法错误时，会返回ErrBadPattern。

Windows系统中，不能进行转义：'\\'被视为路径分隔符。

### func [Glob](https://github.com/golang/go/blob/master/src/path/filepath/match.go?name=release#231)

```go
func Glob(pattern string) (matches []string, err error)
```

Glob函数返回所有匹配模式匹配字符串pattern的文件或者nil（如果没有匹配的文件）。pattern的语法和Match函数相同。pattern可以描述多层的名字，如/usr/*/bin/ed（假设路径分隔符是'/'）。

### type [WalkFunc](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#337)

```go
type WalkFunc func(path string, info os.FileInfo, err error) error
```

Walk函数对每一个文件/目录都会调用WalkFunc函数类型值。调用时path参数会包含Walk的root参数作为前缀；就是说，如果Walk函数的root为"dir"，该目录下有文件"a"，将会使用"dir/a"调用walkFn参数。walkFn参数被调用时的info参数是path指定的地址（文件/目录）的文件信息，类型为os.FileInfo。

如果遍历path指定的文件或目录时出现了问题，传入的参数err会描述该问题，WalkFunc类型函数可以决定如何去处理该错误（Walk函数将不会深入该目录）；如果该函数返回一个错误，Walk函数的执行会中止；只有一个例外，如果Walk的walkFn返回值是SkipDir，将会跳过该目录的内容而Walk函数照常执行处理下一个文件。

### func [Walk](https://github.com/golang/go/blob/master/src/path/filepath/path.go?name=release#385)

```go
func Walk(root string, walkFn WalkFunc) error
```

Walk函数会遍历root指定的目录下的文件树，对每一个该文件树中的目录和文件都会调用walkFn，包括root自身。所有访问文件/目录时遇到的错误都会传递给walkFn过滤。文件是按词法顺序遍历的，这让输出更漂亮，但也导致处理非常大的目录时效率会降低。Walk函数不会遍历文件树中的符号链接（快捷方式）文件包含的路径。

### func [HasPrefix](https://github.com/golang/go/blob/master/src/path/filepath/path_unix.go?name=release#23)

```go
func HasPrefix(p, prefix string) bool
```

HasPrefix函数出于历史兼容问题保留，不应被使用。

# os包

package os

```go
import "os"
```

os包提供了操作系统函数的不依赖平台的接口。设计为Unix风格的，虽然错误处理是go风格的；失败的调用会返回错误值而非错误码。通常错误值里包含更多信息。例如，如果某个使用一个文件名的调用（如Open、Stat）失败了，打印错误时会包含该文件名，错误类型将为*PathError，其内部可以解包获得更多信息。

os包的接口规定为在所有操作系统中都是一致的。非公用的属性可以从操作系统特定的[syscall](http://godoc.org/syscall)包获取。

下面是一个简单的例子，打开一个文件并从中读取一些数据：

```go
file, err := os.Open("file.go") // For read access.
if err != nil {
	log.Fatal(err)
}
```

如果打开失败，错误字符串是自解释的，例如：

```go
open file.go: no such file or directory
```

文件的信息可以读取进一个[]byte切片。Read和Write方法从切片参数获取其内的字节数。

```go
data := make([]byte, 100)
count, err := file.Read(data)
if err != nil {
	log.Fatal(err)
}
fmt.Printf("read %d bytes: %q\n", count, data[:count])
```

### Constants

```go
const (
    O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件
    O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件
    O_RDWR   int = syscall.O_RDWR   // 读写模式打开文件
    O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部
    O_CREATE int = syscall.O_CREAT  // 如果不存在将创建一个新文件
    O_EXCL   int = syscall.O_EXCL   // 和O_CREATE配合使用，文件必须不存在
    O_SYNC   int = syscall.O_SYNC   // 打开文件用于同步I/O
    O_TRUNC  int = syscall.O_TRUNC  // 如果可能，打开时清空文件
)
```

用于包装底层系统的参数用于Open函数，不是所有的flag都能在特定系统里使用的。

```go
const (
    SEEK_SET int = 0 // 相对于文件起始位置seek
    SEEK_CUR int = 1 // 相对于文件当前位置seek
    SEEK_END int = 2 // 相对于文件结尾位置seek
)
```

指定Seek函数从何处开始搜索（即相对位置）

```go
const (
    PathSeparator     = '/' // 操作系统指定的路径分隔符
    PathListSeparator = ':' // 操作系统指定的表分隔符
)
const DevNull = "/dev/null"
```

DevNull是操作系统空设备的名字。在类似Unix的操作系统中，是"/dev/null"；在Windows中，为"NUL"。

### Variables

```go
var (
    ErrInvalid    = errors.New("invalid argument")
    ErrPermission = errors.New("permission denied")
    ErrExist      = errors.New("file already exists")
    ErrNotExist   = errors.New("file does not exist")
)
```

一些可移植的、共有的系统调用错误。

```go
var (
    Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
    Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
    Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
)
```

Stdin、Stdout和Stderr是指向标准输入、标准输出、标准错误输出的文件描述符。

```go
var Args []string
```

Args保管了命令行参数，第一个是程序名。

### func [Hostname](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#92)

```go
func Hostname() (name string, err error)
```

Hostname返回内核提供的主机名。

### func [Getpagesize](https://github.com/golang/go/blob/master/src/os/types.go?name=release#13)

```go
func Getpagesize() int
```

Getpagesize返回底层的系统内存页的尺寸。

### func [Environ](https://github.com/golang/go/blob/master/src/os/env.go?name=release#101)

```go
func Environ() []string
```

Environ返回表示环境变量的格式为"key=value"的字符串的切片拷贝。

### func [Getenv](https://github.com/golang/go/blob/master/src/os/env.go?name=release#79)

```go
func Getenv(key string) string
```

Getenv检索并返回名为key的环境变量的值。如果不存在该环境变量会返回空字符串。

### func [Setenv](https://github.com/golang/go/blob/master/src/os/env.go?name=release#86)

```go
func Setenv(key, value string) error
```

Setenv设置名为key的环境变量。如果出错会返回该错误。

### func [Clearenv](https://github.com/golang/go/blob/master/src/os/env.go?name=release#95)

```go
func Clearenv()
```

Clearenv删除所有环境变量。

### func [Exit](https://github.com/golang/go/blob/master/src/os/proc.go?name=release#36)

```go
func Exit(code int)
```

Exit让当前程序以给出的状态码code退出。一般来说，状态码0表示成功，非0表示出错。程序会立刻终止，defer的函数不会被执行。

### func [Expand](https://github.com/golang/go/blob/master/src/os/env.go?name=release#13)

```go
func Expand(s string, mapping func(string) string) string
```

Expand函数替换s中的${var}或$var为mapping(var)。例如，os.ExpandEnv(s)等价于os.Expand(s, os.Getenv)。

### func [ExpandEnv](https://github.com/golang/go/blob/master/src/os/env.go?name=release#32)

```go
func ExpandEnv(s string) string
```

ExpandEnv函数替换s中的${var}或$var为名为var 的环境变量的值。引用未定义环境变量会被替换为空字符串。

### func [Getuid](https://github.com/golang/go/blob/master/src/os/proc.go?name=release#15)

```go
func Getuid() int
```

Getuid返回调用者的用户ID。

### func [Geteuid](https://github.com/golang/go/blob/master/src/os/proc.go?name=release#18)

```go
func Geteuid() int
```

Geteuid返回调用者的有效用户ID。

### func [Getgid](https://github.com/golang/go/blob/master/src/os/proc.go?name=release#21)

```go
func Getgid() int
```

Getgid返回调用者的组ID。

### func [Getegid](https://github.com/golang/go/blob/master/src/os/proc.go?name=release#24)

```go
func Getegid() int
```

Getegid返回调用者的有效组ID。

### func [Getgroups](https://github.com/golang/go/blob/master/src/os/proc.go?name=release#27)

```go
func Getgroups() ([]int, error)
```

Getgroups返回调用者所属的所有用户组的组ID。

### func [Getpid](https://github.com/golang/go/blob/master/src/os/exec.go?name=release#67)

```go
func Getpid() int
```

Getpid返回调用者所在进程的进程ID。

### func [Getppid](https://github.com/golang/go/blob/master/src/os/exec.go?name=release#70)

```go
func Getppid() int
```

Getppid返回调用者所在进程的父进程的进程ID。

### type [Signal](https://github.com/golang/go/blob/master/src/os/exec.go?name=release#61)

```go
type Signal interface {
    String() string
    Signal() // 用来区分其他实现了Stringer接口的类型
}
```

Signal代表一个操作系统信号。一般其底层实现是依赖于操作系统的：在Unix中，它是syscall.Signal类型。

```go
var (
    Interrupt Signal = syscall.SIGINT
    Kill      Signal = syscall.SIGKILL
)
```

仅有的肯定会被所有操作系统提供的信号，Interrupt（中断信号）和Kill（强制退出信号）。

### type [PathError](https://github.com/golang/go/blob/master/src/os/error.go?name=release#20)

```go
type PathError struct {
    Op   string
    Path string
    Err  error
}
```

PathError记录一个错误，以及导致错误的路径。

#### func (*PathError) [Error](https://github.com/golang/go/blob/master/src/os/error.go?name=release#26)

```go
func (e *PathError) Error() string
```

### type [LinkError](https://github.com/golang/go/blob/master/src/os/file.go?name=release#77)

```go
type LinkError struct {
    Op  string
    Old string
    New string
    Err error
}
```

LinkError记录在Link、Symlink、Rename系统调用时出现的错误，以及导致错误的路径。

#### func (*LinkError) [Error](https://github.com/golang/go/blob/master/src/os/file.go?name=release#84)

```go
func (e *LinkError) Error() string
```

### type [SyscallError](https://github.com/golang/go/blob/master/src/os/error.go?name=release#29)

```go
type SyscallError struct {
    Syscall string
    Err     error
}
```

SyscallError记录某个系统调用出现的错误。

#### func (*SyscallError) [Error](https://github.com/golang/go/blob/master/src/os/error.go?name=release#34)

```go
func (e *SyscallError) Error() string
```

#### func [NewSyscallError](https://github.com/golang/go/blob/master/src/os/error.go?name=release#39)

```go
func NewSyscallError(syscall string, err error) error
```

NewSyscallError返回一个指定系统调用名称和错误细节的SyscallError。如果err为nil，本函数会返回nil。

### type [FileMode](https://github.com/golang/go/blob/master/src/os/types.go?name=release#30)

```go
type FileMode uint32
```

FileMode代表文件的模式和权限位。这些字位在所有的操作系统都有相同的含义，因此文件的信息可以在不同的操作系统之间安全的移植。不是所有的位都能用于所有的系统，唯一共有的是用于表示目录的ModeDir位。

```go
const (
    // 单字符是被String方法用于格式化的属性缩写。
    ModeDir        FileMode = 1 << (32 - 1 - iota) // d: 目录
    ModeAppend                                     // a: 只能写入，且只能写入到末尾
    ModeExclusive                                  // l: 用于执行
    ModeTemporary                                  // T: 临时文件（非备份文件）
    ModeSymlink                                    // L: 符号链接（不是快捷方式文件）
    ModeDevice                                     // D: 设备
    ModeNamedPipe                                  // p: 命名管道（FIFO）
    ModeSocket                                     // S: Unix域socket
    ModeSetuid                                     // u: 表示文件具有其创建者用户id权限
    ModeSetgid                                     // g: 表示文件具有其创建者组id的权限
    ModeCharDevice                                 // c: 字符设备，需已设置ModeDevice
    ModeSticky                                     // t: 只有root/创建者能删除/移动文件
    // 覆盖所有类型位（用于通过&获取类型位），对普通文件，所有这些位都不应被设置
    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice
    ModePerm FileMode = 0777 // 覆盖所有Unix权限位（用于通过&获取类型位）
)
```

这些被定义的位是FileMode最重要的位。另外9个不重要的位为标准Unix rwxrwxrwx权限（任何人都可读、写、运行）。这些（重要）位的值应被视为公共API的一部分，可能会用于线路协议或硬盘标识：它们不能被修改，但可以添加新的位。

#### func (FileMode) [IsDir](https://github.com/golang/go/blob/master/src/os/types.go?name=release#87)

```go
func (m FileMode) IsDir() bool
```

IsDir报告m是否是一个目录。

#### func (FileMode) [IsRegular](https://github.com/golang/go/blob/master/src/os/types.go?name=release#93)

```go
func (m FileMode) IsRegular() bool
```

IsRegular报告m是否是一个普通文件。

#### func (FileMode) [Perm](https://github.com/golang/go/blob/master/src/os/types.go?name=release#98)

```go
func (m FileMode) Perm() FileMode
```

Perm方法返回m的Unix权限位。

#### func (FileMode) [String](https://github.com/golang/go/blob/master/src/os/types.go?name=release#59)

```go
func (m FileMode) String() string
```

### type [FileInfo](https://github.com/golang/go/blob/master/src/os/types.go?name=release#16)

```go
type FileInfo interface {
    Name() string       // 文件的名字（不含扩展名）
    Size() int64        // 普通文件返回值表示其大小；其他文件的返回值含义各系统不同
    Mode() FileMode     // 文件的模式位
    ModTime() time.Time // 文件的修改时间
    IsDir() bool        // 等价于Mode().IsDir()
    Sys() interface{}   // 底层数据来源（可以返回nil）
}
```

FileInfo用来描述一个文件对象。

#### func [Stat](https://github.com/golang/go/blob/master/src/os/file_unix.go?name=release#131)

```go
func Stat(name string) (fi FileInfo, err error)
```

Stat返回一个描述name指定的文件对象的FileInfo。如果指定的文件对象是一个符号链接，返回的FileInfo描述该符号链接指向的文件的信息，本函数会尝试跳转该链接。如果出错，返回的错误值为*PathError类型。

#### func [Lstat](https://github.com/golang/go/blob/master/src/os/file_unix.go?name=release#144)

```go
func Lstat(name string) (fi FileInfo, err error)
```

Lstat返回一个描述name指定的文件对象的FileInfo。如果指定的文件对象是一个符号链接，返回的FileInfo描述该符号链接的信息，本函数不会试图跳转该链接。如果出错，返回的错误值为*PathError类型。

### func [IsPathSeparator](https://github.com/golang/go/blob/master/src/os/path_unix.go?name=release#15)

```go
func IsPathSeparator(c uint8) bool
```

IsPathSeparator返回字符c是否是一个路径分隔符。

### func [IsExist](https://github.com/golang/go/blob/master/src/os/error.go?name=release#49)

```go
func IsExist(err error) bool
```

返回一个布尔值说明该错误是否表示一个文件或目录已经存在。ErrExist和一些系统调用错误会使它返回真。

### func [IsNotExist](https://github.com/golang/go/blob/master/src/os/error.go?name=release#56)

```go
func IsNotExist(err error) bool
```

返回一个布尔值说明该错误是否表示一个文件或目录不存在。ErrNotExist和一些系统调用错误会使它返回真。

### func [IsPermission](https://github.com/golang/go/blob/master/src/os/error.go?name=release#63)

```go
func IsPermission(err error) bool
```

返回一个布尔值说明该错误是否表示因权限不足要求被拒绝。ErrPermission和一些系统调用错误会使它返回真。

### func [Getwd](https://github.com/golang/go/blob/master/src/os/getwd.go?name=release#25)

```go
func Getwd() (dir string, err error)
```

Getwd返回一个对应当前工作目录的根路径。如果当前目录可以经过多条路径抵达（因为硬链接），Getwd会返回其中一个。

### func [Chdir](https://github.com/golang/go/blob/master/src/os/file.go?name=release#214)

```go
func Chdir(dir string) error
```

Chdir将当前工作目录修改为dir指定的目录。如果出错，会返回*PathError底层类型的错误。

### func [Chmod](https://github.com/golang/go/blob/master/src/os/file_posix.go?name=release#78)

```go
func Chmod(name string, mode FileMode) error
```

Chmod修改name指定的文件对象的mode。如果name指定的文件是一个符号链接，它会修改该链接的目的地文件的mode。如果出错，会返回*PathError底层类型的错误。

### func [Chown](https://github.com/golang/go/blob/master/src/os/file_posix.go?name=release#100)

```go
func Chown(name string, uid, gid int) error
```

Chmod修改name指定的文件对象的用户id和组id。如果name指定的文件是一个符号链接，它会修改该链接的目的地文件的用户id和组id。如果出错，会返回*PathError底层类型的错误。

### func [Lchown](https://github.com/golang/go/blob/master/src/os/file_posix.go?name=release#110)

```go
func Lchown(name string, uid, gid int) error
```

Chmod修改name指定的文件对象的用户id和组id。如果name指定的文件是一个符号链接，它会修改该符号链接自身的用户id和组id。如果出错，会返回*PathError底层类型的错误。

### func [Chtimes](https://github.com/golang/go/blob/master/src/os/file_posix.go?name=release#161)

```go
func Chtimes(name string, atime time.Time, mtime time.Time) error
```

Chtimes修改name指定的文件对象的访问时间和修改时间，类似Unix的utime()或utimes()函数。底层的文件系统可能会截断/舍入时间单位到更低的精确度。如果出错，会返回*PathError底层类型的错误。

### func [Mkdir](https://github.com/golang/go/blob/master/src/os/file.go?name=release#204)

```go
func Mkdir(name string, perm FileMode) error
```

Mkdir使用指定的权限和名称创建一个目录。如果出错，会返回*PathError底层类型的错误。

### func [MkdirAll](https://github.com/golang/go/blob/master/src/os/path.go?name=release#19)

```go
func MkdirAll(path string, perm FileMode) error
```

MkdirAll使用指定的权限和名称创建一个目录，包括任何必要的上级目录，并返回nil，否则返回错误。权限位perm会应用在每一个被本函数创建的目录上。如果path指定了一个已经存在的目录，MkdirAll不做任何操作并返回nil。

### func [Rename](https://github.com/golang/go/blob/master/src/os/file.go?name=release#255)

```go
func Rename(oldpath, newpath string) error
```

Rename修改一个文件的名字，移动一个文件。可能会有一些个操作系统特定的限制。

### func [Truncate](https://github.com/golang/go/blob/master/src/os/file_unix.go?name=release#251)

```go
func Truncate(name string, size int64) error
```

Truncate修改name指定的文件的大小。如果该文件为一个符号链接，将修改链接指向的文件的大小。如果出错，会返回*PathError底层类型的错误。

### func [Remove](https://github.com/golang/go/blob/master/src/os/file_unix.go?name=release#260)

```go
func Remove(name string) error
```

Remove删除name指定的文件或目录。如果出错，会返回*PathError底层类型的错误。

### func [RemoveAll](https://github.com/golang/go/blob/master/src/os/path.go?name=release#66)

```go
func RemoveAll(path string) error
```

RemoveAll删除path指定的文件，或目录及它包含的任何下级对象。它会尝试删除所有东西，除非遇到错误并返回。如果path指定的对象不存在，RemoveAll会返回nil而不返回错误。

### func [Readlink](https://github.com/golang/go/blob/master/src/os/file_posix.go?name=release#38)

```go
func Readlink(name string) (string, error)
```

Readlink获取name指定的符号链接文件指向的文件的路径。如果出错，会返回*PathError底层类型的错误。

### func [Symlink](https://github.com/golang/go/blob/master/src/os/file_posix.go?name=release#28)

```go
func Symlink(oldname, newname string) error
```

Symlink创建一个名为newname指向oldname的符号链接。如果出错，会返回* LinkError底层类型的错误。

### func [Link](https://github.com/golang/go/blob/master/src/os/file_posix.go?name=release#18)

```go
func Link(oldname, newname string) error
```

Link创建一个名为newname指向oldname的硬链接。如果出错，会返回* LinkError底层类型的错误。

### func [SameFile](https://github.com/golang/go/blob/master/src/os/types.go?name=release#111)

```go
func SameFile(fi1, fi2 FileInfo) bool
```

SameFile返回fi1和fi2是否在描述同一个文件。例如，在Unix这表示二者底层结构的设备和索引节点是相同的；在其他系统中可能是根据路径名确定的。SameFile应只使用本包Stat函数返回的FileInfo类型值为参数，其他情况下，它会返回假。

### func [TempDir](https://github.com/golang/go/blob/master/src/os/file_unix.go?name=release#308)

```go
func TempDir() string
```

TempDir返回一个用于保管临时文件的默认目录。

### type [File](https://github.com/golang/go/blob/master/src/os/file_unix.go?name=release#16)

```go
type File struct {
    // 内含隐藏或非导出字段
}
```

File代表一个打开的文件对象。

#### func [Create](https://github.com/golang/go/blob/master/src/os/file.go?name=release#247)

```go
func Create(name string) (file *File, err error)
```

Create采用模式0666（任何人都可读写，不可执行）创建一个名为name的文件，如果文件已存在会截断它（为空文件）。如果成功，返回的文件对象可用于I/O；对应的文件描述符具有O_RDWR模式。如果出错，错误底层类型是*PathError。

#### func [Open](https://github.com/golang/go/blob/master/src/os/file.go?name=release#238)

```go
func Open(name string) (file *File, err error)
```

Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError。

#### func [OpenFile](https://github.com/golang/go/blob/master/src/os/file_unix.go?name=release#76)

```go
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
```

OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。

#### func [NewFile](https://github.com/golang/go/blob/master/src/os/file_unix.go?name=release#40)

```go
func NewFile(fd uintptr, name string) *File
```

NewFile使用给出的Unix文件描述符和名称创建一个文件。

#### func [Pipe](https://github.com/golang/go/blob/master/src/os/pipe_linux.go?name=release#11)

```go
func Pipe() (r *File, w *File, err error)
```

Pipe返回一对关联的文件对象。从r的读取将返回写入w的数据。本函数会返回两个文件对象和可能的错误。

#### func (*File) [Name](https://github.com/golang/go/blob/master/src/os/file.go?name=release#45)

```go
func (f *File) Name() string
```

Name方法返回（提供给Open/Create等方法的）文件名称。

#### func (*File) [Stat](https://github.com/golang/go/blob/master/src/os/file_unix.go?name=release#117)

```go
func (f *File) Stat() (fi FileInfo, err error)
```

Stat返回描述文件f的FileInfo类型值。如果出错，错误底层类型是*PathError。

#### func (*File) [Fd](https://github.com/golang/go/blob/master/src/os/file_unix.go?name=release#32)

```go
func (f *File) Fd() uintptr
```

Fd返回与文件f对应的整数类型的Unix文件描述符。

#### func (*File) [Chdir](https://github.com/golang/go/blob/master/src/os/file.go?name=release#224)

```go
func (f *File) Chdir() error
```

Chdir将当前工作目录修改为f，f必须是一个目录。如果出错，错误底层类型是*PathError。

#### func (*File) [Chmod](https://github.com/golang/go/blob/master/src/os/file_posix.go?name=release#87)

```go
func (f *File) Chmod(mode FileMode) error
```

Chmod修改文件的模式。如果出错，错误底层类型是*PathError。

#### func (*File) [Chown](https://github.com/golang/go/blob/master/src/os/file_posix.go?name=release#119)

```go
func (f *File) Chown(uid, gid int) error
```

Chown修改文件的用户ID和组ID。如果出错，错误底层类型是*PathError。

#### func (*File) [Readdir](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#111)

```go
func (f *File) Readdir(n int) (fi []FileInfo, err error)
```

Readdir读取目录f的内容，返回一个有n个成员的[]FileInfo，这些FileInfo是被Lstat返回的，采用目录顺序。对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。

如果n>0，Readdir函数会返回一个最多n个成员的切片。这时，如果Readdir返回一个空切片，它会返回一个非nil的错误说明原因。如果到达了目录f的结尾，返回值err会是io.EOF。

如果n<=0，Readdir函数返回目录中剩余所有文件对象的FileInfo构成的切片。此时，如果Readdir调用成功（读取所有内容直到结尾），它会返回该切片和nil的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的FileInfo构成的切片和该错误。

#### func (*File) [Readdirnames](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#130)

```go
func (f *File) Readdirnames(n int) (names []string, err error)
```

Readdir读取目录f的内容，返回一个有n个成员的[]string，切片成员为目录中文件对象的名字，采用目录顺序。对本函数的下一次调用会返回上一次调用剩余未读取的内容的信息。

如果n>0，Readdir函数会返回一个最多n个成员的切片。这时，如果Readdir返回一个空切片，它会返回一个非nil的错误说明原因。如果到达了目录f的结尾，返回值err会是io.EOF。

如果n<=0，Readdir函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果Readdir调用成功（读取所有内容直到结尾），它会返回该切片和nil的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。

#### func (*File) [Truncate](https://github.com/golang/go/blob/master/src/os/file_posix.go?name=release#132)

```go
func (f *File) Truncate(size int64) error
```

Truncate改变文件的大小，它不会改变I/O的当前位置。 如果截断文件，多出的部分就会被丢弃。如果出错，错误底层类型是*PathError。

#### func (*File) [Read](https://github.com/golang/go/blob/master/src/os/file.go?name=release#91)

```go
func (f *File) Read(b []byte) (n int, err error)
```

Read方法从f中读取最多len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。文件终止标志是读取0个字节且返回值err为io.EOF。

#### func (*File) [ReadAt](https://github.com/golang/go/blob/master/src/os/file.go?name=release#112)

```go
func (f *File) ReadAt(b []byte, off int64) (n int, err error)
```

ReadAt从指定的位置（相对于文件开始位置）读取len(b)字节数据并写入b。它返回读取的字节数和可能遇到的任何错误。当n<len(b)时，本方法总是会返回错误；如果是因为到达文件结尾，返回值err会是io.EOF。

#### func (*File) [Write](https://github.com/golang/go/blob/master/src/os/file.go?name=release#135)

```go
func (f *File) Write(b []byte) (n int, err error)
```

Write向文件中写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。

#### func (*File) [WriteString](https://github.com/golang/go/blob/master/src/os/file.go?name=release#195)

```go
func (f *File) WriteString(s string) (ret int, err error)
```

WriteString类似Write，但接受一个字符串参数。

#### func (*File) [WriteAt](https://github.com/golang/go/blob/master/src/os/file.go?name=release#158)

```go
func (f *File) WriteAt(b []byte, off int64) (n int, err error)
```

WriteAt在指定的位置（相对于文件开始位置）写入len(b)字节数据。它返回写入的字节数和可能遇到的任何错误。如果返回值n!=len(b)，本方法会返回一个非nil的错误。

#### func (*File) [Seek](https://github.com/golang/go/blob/master/src/os/file.go?name=release#179)

```
func (f *File) Seek(offset int64, whence int) (ret int64, err error)
```

Seek设置下一次读/写的位置。offset为相对偏移量，而whence决定相对位置：0为相对文件开头，1为相对当前位置，2为相对文件结尾。它返回新的偏移量（相对开头）和可能的错误。

#### func (*File) [Sync](https://github.com/golang/go/blob/master/src/os/file_posix.go?name=release#145)

```go
func (f *File) Sync() (err error)
```

Sync递交文件的当前内容进行稳定的存储。一般来说，这表示将文件系统的最近写入的数据在内存中的拷贝刷新到硬盘中稳定保存。

#### func (*File) [Close](https://github.com/golang/go/blob/master/src/os/file_unix.go?name=release#93)

```go
func (f *File) Close() error
```

Close关闭文件f，使文件不能用于读写。它返回可能出现的错误。

### type [ProcAttr](https://github.com/golang/go/blob/master/src/os/exec.go?name=release#36)

```go
type ProcAttr struct {
    // 如果Dir非空，子进程会在创建进程前先进入该目录。（即设为当前工作目录）
    Dir string
    // 如果Env非空，它会作为新进程的环境变量。必须采用Environ返回值的格式。
    // 如果Env为空字符串，将使用Environ函数的返回值。
    Env []string
    // Files指定被新进程继承的活动文件对象。
    // 前三个绑定为标准输入、标准输出、标准错误输出。
    // 依赖底层操作系统的实现可能会支持额外的数据出入途径。
    // nil条目相当于在进程开始时关闭的文件对象。
    Files []*File
    // 操作系统特定的创建属性。
    // 注意设置本字段意味着你的程序可能会运作失常甚至在某些操作系统中无法通过编译。
    Sys *syscall.SysProcAttr
}
```

ProcAttr保管将被StartProcess函数用于一个新进程的属性。

### type [Process](https://github.com/golang/go/blob/master/src/os/exec.go?name=release#14)

```go
type Process struct {
    Pid int
    // 内含隐藏或非导出字段
}
```

Process保管一个被StarProcess创建的进程的信息。

#### func [FindProcess](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#12)

```go
func FindProcess(pid int) (p *Process, err error)
```

FindProcess根据进程id查找一个运行中的进程。函数返回的进程对象可以用于获取其关于底层操作系统进程的信息。

#### func [StartProcess](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#23)

```go
func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)
```

StartProcess使用提供的属性、程序名、命令行参数开始一个新进程。StartProcess函数是一个低水平的接口。os/exec包提供了高水平的接口，应该尽量使用该包。如果出错，错误的底层类型会是*PathError。

#### func (*Process) [Signal](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#50)

```go
func (p *Process) Signal(sig Signal) error
```

Signal方法向进程发送一个信号。在windows中向进程发送Interrupt信号尚未实现。

#### func (*Process) [Kill](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#35)

```go
func (p *Process) Kill() error
```

Kill让进程立刻退出。

#### func (*Process) [Wait](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#44)

```go
func (p *Process) Wait() (*ProcessState, error)
```

Wait方法阻塞直到进程退出，然后返回一个描述ProcessState描述进程的状态和可能的错误。Wait方法会释放绑定到进程p的所有资源。在大多数操作系统中，进程p必须是当前进程的子进程，否则会返回错误。

#### func (*Process) [Release](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#30)

```go
func (p *Process) Release() error
```

Release释放进程p绑定的所有资源， 使它们（资源）不能再被（进程p）使用。只有没有调用Wait方法时才需要调用本方法。

### type [ProcessState](https://github.com/golang/go/blob/master/src/os/exec_posix.go?name=release#57)

```go
type ProcessState struct {
    // 内含隐藏或非导出字段
}
```

ProcessState保管Wait函数报告的某个已退出进程的信息。

#### func (*ProcessState) [Pid](https://github.com/golang/go/blob/master/src/os/exec_posix.go?name=release#64)

```go
func (p *ProcessState) Pid() int
```

Pi返回一个已退出的进程的进程id。

#### func (*ProcessState) [Exited](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#65)

```go
func (p *ProcessState) Exited() bool
```

Exited报告进程是否已退出。

#### func (*ProcessState) [Success](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#71)

```go
func (p *ProcessState) Success() bool
```

Success报告进程是否成功退出，如在Unix里以状态码0退出。

#### func (*ProcessState) [SystemTime](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#60)

```go
func (p *ProcessState) SystemTime() time.Duration
```

SystemTime返回已退出进程及其子进程耗费的系统CPU时间。

#### func (*ProcessState) [UserTime](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#55)

```go
func (p *ProcessState) UserTime() time.Duration
```

UserTime返回已退出进程及其子进程耗费的用户CPU时间。

#### func (*ProcessState) [Sys](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#78)

```go
func (p *ProcessState) Sys() interface{}
```

Sys返回该已退出进程系统特定的退出信息。需要将其类型转换为适当的底层类型，如Unix里转换为*syscall.WaitStatus类型以获取其内容。

#### func (*ProcessState) [SysUsage](https://github.com/golang/go/blob/master/src/os/doc.go?name=release#87)

```go
func (p *ProcessState) SysUsage() interface{}
```

SysUsage返回该已退出进程系统特定的资源使用信息。需要将其类型转换为适当的底层类型，如Unix里转换为*syscall.Rusage类型以获取其内容。

#### func (*ProcessState) [String](https://github.com/golang/go/blob/master/src/os/exec_posix.go?name=release#111)

```go
func (p *ProcessState) String() string
```

# net/http包

package http

```go
import "net/http"
```

http包提供了HTTP客户端和服务端的实现。

Get、Head、Post和PostForm函数发出HTTP/ HTTPS请求。

```go
resp, err := http.Get("http://example.com/")
...
resp, err := http.Post("http://example.com/upload", "image/jpeg", &buf)
...
resp, err := http.PostForm("http://example.com/form",
	url.Values{"key": {"Value"}, "id": {"123"}})
```

程序在使用完回复后必须关闭回复的主体。

```go
resp, err := http.Get("http://example.com/")
if err != nil {
	// handle error
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
// ...
```

要管理HTTP客户端的头域、重定向策略和其他设置，创建一个Client：

```go
client := &http.Client{
	CheckRedirect: redirectPolicyFunc,
}
resp, err := client.Get("http://example.com")
// ...
req, err := http.NewRequest("GET", "http://example.com", nil)
// ...
req.Header.Add("If-None-Match", `W/"wyzzy"`)
resp, err := client.Do(req)
// ...
```

要管理代理、TLS配置、keep-alive、压缩和其他设置，创建一个Transport：

```go
tr := &http.Transport{
	TLSClientConfig:    &tls.Config{RootCAs: pool},
	DisableCompression: true,
}
client := &http.Client{Transport: tr}
resp, err := client.Get("https://example.com")
```

Client和Transport类型都可以安全的被多个go程同时使用。出于效率考虑，应该一次建立、尽量重用。

ListenAndServe使用指定的监听地址和处理器启动一个HTTP服务端。处理器参数通常是nil，这表示采用包变量DefaultServeMux作为处理器。Handle和HandleFunc函数可以向DefaultServeMux添加处理器。

```go
http.Handle("/foo", fooHandler)
http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))
})
log.Fatal(http.ListenAndServe(":8080", nil))
```

要管理服务端的行为，可以创建一个自定义的Server：

```go
s := &http.Server{
	Addr:           ":8080",
	Handler:        myHandler,
	ReadTimeout:    10 * time.Second,
	WriteTimeout:   10 * time.Second,
	MaxHeaderBytes: 1 << 20,
}
log.Fatal(s.ListenAndServe())
```

```go
const (
    StatusContinue           = 100
    StatusSwitchingProtocols = 101
    StatusOK                   = 200
    StatusCreated              = 201
    StatusAccepted             = 202
    StatusNonAuthoritativeInfo = 203
    StatusNoContent            = 204
    StatusResetContent         = 205
    StatusPartialContent       = 206
    StatusMultipleChoices   = 300
    StatusMovedPermanently  = 301
    StatusFound             = 302
    StatusSeeOther          = 303
    StatusNotModified       = 304
    StatusUseProxy          = 305
    StatusTemporaryRedirect = 307
    StatusBadRequest                   = 400
    StatusUnauthorized                 = 401
    StatusPaymentRequired              = 402
    StatusForbidden                    = 403
    StatusNotFound                     = 404
    StatusMethodNotAllowed             = 405
    StatusNotAcceptable                = 406
    StatusProxyAuthRequired            = 407
    StatusRequestTimeout               = 408
    StatusConflict                     = 409
    StatusGone                         = 410
    StatusLengthRequired               = 411
    StatusPreconditionFailed           = 412
    StatusRequestEntityTooLarge        = 413
    StatusRequestURITooLong            = 414
    StatusUnsupportedMediaType         = 415
    StatusRequestedRangeNotSatisfiable = 416
    StatusExpectationFailed            = 417
    StatusTeapot                       = 418
    StatusInternalServerError     = 500
    StatusNotImplemented          = 501
    StatusBadGateway              = 502
    StatusServiceUnavailable      = 503
    StatusGatewayTimeout          = 504
    StatusHTTPVersionNotSupported = 505
)
```

HTTP状态码，参见[RFC 2616](http://tools.ietf.org/html/rfc2616)

```go
const DefaultMaxHeaderBytes = 1 << 20 // 1 MB
```

DefaultMaxHeaderBytes是HTTP请求的头域最大允许长度。可以通过设置Server.MaxHeaderBytes字段来覆盖。

```go
const DefaultMaxIdleConnsPerHost = 2
```

DefaultMaxIdleConnsPerHost是Transport的MaxIdleConnsPerHost的默认值。

```go
const TimeFormat = "Mon, 02 Jan 2006 15:04:05 GMT"
```

TimeFormat是当解析或生产HTTP头域中的时间时，用与time.Parse或time.Format函数的时间格式。这种格式类似time.RFC1123但强制采用GMT时区。

### Variables

```go
var (
    ErrHeaderTooLong        = &ProtocolError{"header too long"}
    ErrShortBody            = &ProtocolError{"entity body too short"}
    ErrNotSupported         = &ProtocolError{"feature not supported"}
    ErrUnexpectedTrailer    = &ProtocolError{"trailer header without chunked transfer encoding"}
    ErrMissingContentLength = &ProtocolError{"missing ContentLength in HEAD response"}
    ErrNotMultipart         = &ProtocolError{"request Content-Type isn't multipart/form-data"}
    ErrMissingBoundary      = &ProtocolError{"no multipart boundary param in Content-Type"}
)
```

HTTP请求的解析错误。

```go
var (
    ErrWriteAfterFlush = errors.New("Conn.Write called after Flush")
    ErrBodyNotAllowed  = errors.New("http: request method or response status code does not allow body")
    ErrHijacked        = errors.New("Conn has been hijacked")
    ErrContentLength   = errors.New("Conn.Write wrote more than the declared Content-Length")
)
```

会被HTTP服务端返回的错误。

```go
var DefaultClient = &Client{}
```

DefaultClient是用于包函数Get、Head和Post的默认Client。

```go
var DefaultServeMux = NewServeMux()
```

DefaultServeMux是用于Serve的默认ServeMux。

```go
var ErrBodyReadAfterClose = errors.New("http: invalid Read on closed Body")
```

在Resquest或Response的Body字段已经关闭后，试图从中读取时，就会返回ErrBodyReadAfterClose。这个错误一般发生在：HTTP处理器中调用完ResponseWriter 接口的WriteHeader或Write后从请求中读取数据的时候。

```go
var ErrHandlerTimeout = errors.New("http: Handler timeout")
```

在处理器超时以后调用ResponseWriter接口的Write方法，就会返回ErrHandlerTimeout。

```go
var ErrLineTooLong = errors.New("header line too long")
var ErrMissingFile = errors.New("http: no such file")
```

当请求中没有提供给FormFile函数的文件字段名，或者该字段名不是文件字段时，该函数就会返回ErrMissingFile。

```go
var ErrNoCookie = errors.New("http: named cookie not present")
var ErrNoLocation = errors.New("http: no Location header in response")
```

### type [ProtocolError](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#38)

```go
type ProtocolError struct {
    ErrorString string
}
```

HTTP请求解析错误。

#### func (*ProtocolError) [Error](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#42)

```go
func (err *ProtocolError) Error() string
```

### func [CanonicalHeaderKey](https://github.com/golang/go/blob/master/src/net/http/header.go?name=release#171)

```go
func CanonicalHeaderKey(s string) string
```

CanonicalHeaderKey函数返回头域（表示为Header类型）的键s的规范化格式。规范化过程中让单词首字母和'-'后的第一个字母大写，其余字母小写。例如，"accept-encoding"规范化为"Accept-Encoding"。

### func [DetectContentType](https://github.com/golang/go/blob/master/src/net/http/sniff.go?name=release#21)

```go
func DetectContentType(data []byte) string
```

DetectContentType函数实现了<http://mimesniff.spec.whatwg.org/>描述的算法，用于确定数据的Content-Type。函数总是返回一个合法的MIME类型；如果它不能确定数据的类型，将返回"application/octet-stream"。它最多检查数据的前512字节。

### func [ParseHTTPVersion](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#448)

```go
func ParseHTTPVersion(vers string) (major, minor int, ok bool)
```

ParseHTTPVersion解析HTTP版本字符串。如"HTTP/1.0"返回(1, 0, true)。

### func [ParseTime](https://github.com/golang/go/blob/master/src/net/http/header.go?name=release#79)

```go
func ParseTime(text string) (t time.Time, err error)
```

ParseTime用3种格式TimeFormat, time.RFC850和time.ANSIC尝试解析一个时间头的值（如Date: header）。

### func [StatusText](https://github.com/golang/go/blob/master/src/net/http/status.go?name=release#118)

```go
func StatusText(code int) string
```

StatusText返回HTTP状态码code对应的文本，如220对应"OK"。如果code是未知的状态码，会返回""。

### type [ConnState](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1614)

```
type ConnState int
```

ConnState代表一个客户端到服务端的连接的状态。本类型用于可选的Server.ConnState回调函数。

```go
const (
    // StateNew代表一个新的连接，将要立刻发送请求。
    // 连接从这个状态开始，然后转变为StateAlive或StateClosed。
    StateNew ConnState = iota
    // StateActive代表一个已经读取了请求数据1到多个字节的连接。
    // 用于StateAlive的Server.ConnState回调函数在将连接交付给处理器之前被触发，
    // 等到请求被处理完后，Server.ConnState回调函数再次被触发。
    // 在请求被处理后，连接状态改变为StateClosed、StateHijacked或StateIdle。
    StateActive
    // StateIdle代表一个已经处理完了请求、处在闲置状态、等待新请求的连接。
    // 连接状态可以从StateIdle改变为StateActive或StateClosed。
    StateIdle
    // 代表一个被劫持的连接。这是一个终止状态，不会转变为StateClosed。
    StateHijacked
    // StateClosed代表一个关闭的连接。
    // 这是一个终止状态。被劫持的连接不会转变为StateClosed。
    StateClosed
)
```

#### func (ConnState) [String](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1655)

```go
func (c ConnState) String() string
```

### type [Header](https://github.com/golang/go/blob/master/src/net/http/header.go?name=release#19)

```go
type Header map[string][]string
```

Header代表HTTP头域的键值对。

#### func (Header) [Get](https://github.com/golang/go/blob/master/src/net/http/header.go?name=release#38)

```go
func (h Header) Get(key string) string
```

Get返回键对应的第一个值，如果键不存在会返回""。如要获取该键对应的值切片，请直接用规范格式的键访问map。

#### func (Header) [Set](https://github.com/golang/go/blob/master/src/net/http/header.go?name=release#30)

```go
func (h Header) Set(key, value string)
```

Set添加键值对到h，如键已存在则会用只有新值一个元素的切片取代旧值切片。

#### func (Header) [Add](https://github.com/golang/go/blob/master/src/net/http/header.go?name=release#23)

```go
func (h Header) Add(key, value string)
```

Add添加键值对到h，如键已存在则会将新的值附加到旧值切片后面。

#### func (Header) [Del](https://github.com/golang/go/blob/master/src/net/http/header.go?name=release#51)

```go
func (h Header) Del(key string)
```

Del删除键值对。

#### func (Header) [Write](https://github.com/golang/go/blob/master/src/net/http/header.go?name=release#56)

```go
func (h Header) Write(w io.Writer) error
```

Write以有线格式将头域写入w。

#### func (Header) [WriteSubset](https://github.com/golang/go/blob/master/src/net/http/header.go?name=release#145)

```go
func (h Header) WriteSubset(w io.Writer, exclude map[string]bool) error
```

WriteSubset以有线格式将头域写入w。当exclude不为nil时，如果h的键值对的键在exclude中存在且其对应值为真，该键值对就不会被写入w。

### type [Cookie](https://github.com/golang/go/blob/master/src/net/http/cookie.go?name=release#23)

```go
type Cookie struct {
    Name       string
    Value      string
    Path       string
    Domain     string
    Expires    time.Time
    RawExpires string
    // MaxAge=0表示未设置Max-Age属性
    // MaxAge<0表示立刻删除该cookie，等价于"Max-Age: 0"
    // MaxAge>0表示存在Max-Age属性，单位是秒
    MaxAge   int
    Secure   bool
    HttpOnly bool
    Raw      string
    Unparsed []string // 未解析的“属性-值”对的原始文本
}
```

Cookie代表一个出现在HTTP回复的头域中Set-Cookie头的值里或者HTTP请求的头域中Cookie头的值里的HTTP cookie。

#### func (*Cookie) [String](https://github.com/golang/go/blob/master/src/net/http/cookie.go?name=release#136)

```go
func (c *Cookie) String() string
```

String返回该cookie的序列化结果。如果只设置了Name和Value字段，序列化结果可用于HTTP请求的Cookie头或者HTTP回复的Set-Cookie头；如果设置了其他字段，序列化结果只能用于HTTP回复的Set-Cookie头。

### type [CookieJar](https://github.com/golang/go/blob/master/src/net/http/jar.go?name=release#17)

```go
type CookieJar interface {
    // SetCookies管理从u的回复中收到的cookie
    // 根据其策略和实现，它可以选择是否存储cookie
    SetCookies(u *url.URL, cookies []*Cookie)
    // Cookies返回发送请求到u时应使用的cookie
    // 本方法有责任遵守RFC 6265规定的标准cookie限制
    Cookies(u *url.URL) []*Cookie
}
```

CookieJar管理cookie的存储和在HTTP请求中的使用。CookieJar的实现必须能安全的被多个go程同时使用。

net/http/cookiejar包提供了一个CookieJar的实现。

### type [Request](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#76)

```go
type Request struct {
    // Method指定HTTP方法（GET、POST、PUT等）。对客户端，""代表GET。
    Method string
    // URL在服务端表示被请求的URI，在客户端表示要访问的URL。
    //
    // 在服务端，URL字段是解析请求行的URI（保存在RequestURI字段）得到的，
    // 对大多数请求来说，除了Path和RawQuery之外的字段都是空字符串。
    // （参见RFC 2616, Section 5.1.2）
    //
    // 在客户端，URL的Host字段指定了要连接的服务器，
    // 而Request的Host字段（可选地）指定要发送的HTTP请求的Host头的值。
    URL *url.URL
    // 接收到的请求的协议版本。本包生产的Request总是使用HTTP/1.1
    Proto      string // "HTTP/1.0"
    ProtoMajor int    // 1
    ProtoMinor int    // 0
    // Header字段用来表示HTTP请求的头域。如果头域（多行键值对格式）为：
    //	accept-encoding: gzip, deflate
    //	Accept-Language: en-us
    //	Connection: keep-alive
    // 则：
    //	Header = map[string][]string{
    //		"Accept-Encoding": {"gzip, deflate"},
    //		"Accept-Language": {"en-us"},
    //		"Connection": {"keep-alive"},
    //	}
    // HTTP规定头域的键名（头名）是大小写敏感的，请求的解析器通过规范化头域的键名来实现这点。
    // 在客户端的请求，可能会被自动添加或重写Header中的特定的头，参见Request.Write方法。
    Header Header
    // Body是请求的主体。
    //
    // 在客户端，如果Body是nil表示该请求没有主体买入GET请求。
    // Client的Transport字段会负责调用Body的Close方法。
    //
    // 在服务端，Body字段总是非nil的；但在没有主体时，读取Body会立刻返回EOF。
    // Server会关闭请求的主体，ServeHTTP处理器不需要关闭Body字段。
    Body io.ReadCloser
    // ContentLength记录相关内容的长度。
    // 如果为-1，表示长度未知，如果>=0，表示可以从Body字段读取ContentLength字节数据。
    // 在客户端，如果Body非nil而该字段为0，表示不知道Body的长度。
    ContentLength int64
    // TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示"identity"编码。
    // 本字段一般会被忽略。当发送或接受请求时，会自动添加或移除"chunked"传输编码。
    TransferEncoding []string
    // Close在服务端指定是否在回复请求后关闭连接，在客户端指定是否在发送请求后关闭连接。
    Close bool
    // 在服务端，Host指定URL会在其上寻找资源的主机。
    // 根据RFC 2616，该值可以是Host头的值，或者URL自身提供的主机名。
    // Host的格式可以是"host:port"。
    //
    // 在客户端，请求的Host字段（可选地）用来重写请求的Host头。
    // 如过该字段为""，Request.Write方法会使用URL字段的Host。
    Host string
    // Form是解析好的表单数据，包括URL字段的query参数和POST或PUT的表单数据。
    // 本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。
    Form url.Values
    // PostForm是解析好的POST或PUT的表单数据。
    // 本字段只有在调用ParseForm后才有效。在客户端，会忽略请求中的本字段而使用Body替代。
    PostForm url.Values
    // MultipartForm是解析好的多部件表单，包括上传的文件。
    // 本字段只有在调用ParseMultipartForm后才有效。
    // 在客户端，会忽略请求中的本字段而使用Body替代。
    MultipartForm *multipart.Form
    // Trailer指定了会在请求主体之后发送的额外的头域。
    //
    // 在服务端，Trailer字段必须初始化为只有trailer键，所有键都对应nil值。
    // （客户端会声明哪些trailer会发送）
    // 在处理器从Body读取时，不能使用本字段。
    // 在从Body的读取返回EOF后，Trailer字段会被更新完毕并包含非nil的值。
    // （如果客户端发送了这些键值对），此时才可以访问本字段。
    //
    // 在客户端，Trail必须初始化为一个包含将要发送的键值对的映射。（值可以是nil或其终值）
    // ContentLength字段必须是0或-1，以启用"chunked"传输编码发送请求。
    // 在开始发送请求后，Trailer可以在读取请求主体期间被修改，
    // 一旦请求主体返回EOF，调用者就不可再修改Trailer。
    //
    // 很少有HTTP客户端、服务端或代理支持HTTP trailer。
    Trailer Header
    // RemoteAddr允许HTTP服务器和其他软件记录该请求的来源地址，一般用于日志。
    // 本字段不是ReadRequest函数填写的，也没有定义格式。
    // 本包的HTTP服务器会在调用处理器之前设置RemoteAddr为"IP:port"格式的地址。
    // 客户端会忽略请求中的RemoteAddr字段。
    RemoteAddr string
    // RequestURI是被客户端发送到服务端的请求的请求行中未修改的请求URI
    // （参见RFC 2616, Section 5.1）
    // 一般应使用URI字段，在客户端设置请求的本字段会导致错误。
    RequestURI string
    // TLS字段允许HTTP服务器和其他软件记录接收到该请求的TLS连接的信息
    // 本字段不是ReadRequest函数填写的。
    // 对启用了TLS的连接，本包的HTTP服务器会在调用处理器之前设置TLS字段，否则将设TLS为nil。
    // 客户端会忽略请求中的TLS字段。
    TLS *tls.ConnectionState
}
```

Request类型代表一个服务端接受到的或者客户端发送出去的HTTP请求。

Request各字段的意义和用途在服务端和客户端是不同的。除了字段本身上方文档，还可参见Request.Write方法和RoundTripper接口的文档。

#### func [NewRequest](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#479)

```go
func NewRequest(method, urlStr string, body io.Reader) (*Request, error)
```

NewRequest使用指定的方法、网址和可选的主题创建并返回一个新的*Request。

如果body参数实现了io.Closer接口，Request返回值的Body 字段会被设置为body，并会被Client类型的Do、Post和PostFOrm方法以及Transport.RoundTrip方法关闭。

#### func [ReadRequest](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#549)

```go
func ReadRequest(b *bufio.Reader) (req *Request, err error)
```

ReadRequest从b读取并解析出一个HTTP请求。（本函数主要用在服务端从下层获取请求）

#### func (*Request) [ProtoAtLeast](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#232)

```go
func (r *Request) ProtoAtLeast(major, minor int) bool
```

ProtoAtLeast报告该请求使用的HTTP协议版本至少是major.minor。

#### func (*Request) [UserAgent](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#238)

```go
func (r *Request) UserAgent() string
```

UserAgent返回请求中的客户端用户代理信息（请求的User-Agent头）。

#### func (*Request) [Referer](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#279)

```go
func (r *Request) Referer() string
```

Referer返回请求中的访问来路信息。（请求的Referer头）

Referer在请求中就是拼错了的，这是HTTP早期就有的错误。该值也可以从用Header["Referer"]获取； 让获取Referer字段变成方法的好处是，编译器可以诊断使用正确单词拼法的req.Referrer()的程序，但却不能诊断使用Header["Referrer"]的程序。

#### func (*Request) [AddCookie](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#262)

```go
func (r *Request) AddCookie(c *Cookie)
```

AddCookie向请求中添加一个cookie。按照[RFC 6265](http://tools.ietf.org/html/rfc6265) section 5.4的跪地，AddCookie不会添加超过一个Cookie头字段。这表示所有的cookie都写在同一行，用分号分隔（cookie内部用逗号分隔属性）。

#### func (*Request) [SetBasicAuth](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#517)

```go
func (r *Request) SetBasicAuth(username, password string)
```

SetBasicAuth使用提供的用户名和密码，采用HTTP基本认证，设置请求的Authorization头。HTTP基本认证会明码传送用户名和密码。

#### func (*Request) [Write](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#350)

```go
func (r *Request) Write(w io.Writer) error
```

Write方法以有线格式将HTTP/1.1请求写入w（用于将请求写入下层TCPConn等）。本方法会考虑请求的如下字段：

```
Host
URL
Method (defaults to "GET")
Header
ContentLength
TransferEncoding
Body
```

如果存在Body，ContentLength字段<= 0且TransferEncoding字段未显式设置为["identity"]，Write方法会显式添加"Transfer-Encoding: chunked"到请求的头域。Body字段会在发送完请求后关闭。

#### func (*Request) [WriteProxy](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#360)

```go
func (r *Request) WriteProxy(w io.Writer) error
```

WriteProxy类似Write但会将请求以HTTP代理期望的格式发送。

尤其是，按照[RFC 2616](http://tools.ietf.org/html/rfc2616) Section 5.1.2，WriteProxy会使用绝对URI（包括协议和主机名）来初始化请求的第1行（Request-URI行）。无论何种情况，WriteProxy都会使用r.Host或r.URL.Host设置Host头。

#### func (*Request) [Cookies](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#243)

```go
func (r *Request) Cookies() []*Cookie
```

Cookies解析并返回该请求的Cookie头设置的cookie。

#### func (*Request) [Cookie](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#251)

```go
func (r *Request) Cookie(name string) (*Cookie, error)
```

Cookie返回请求中名为name的cookie，如果未找到该cookie会返回nil, ErrNoCookie。

#### func (*Request) [ParseForm](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#736)

```go
func (r *Request) ParseForm() error
```

ParseForm解析URL中的查询字符串，并将解析结果更新到r.Form字段。

对于POST或PUT请求，ParseForm还会将body当作表单解析，并将结果既更新到r.PostForm也更新到r.Form。解析结果中，POST或PUT请求主体要优先于URL查询字符串（同名变量，主体的值在查询字符串的值前面）。

如果请求的主体的大小没有被MaxBytesReader函数设定限制，其大小默认限制为开头10MB。

ParseMultipartForm会自动调用ParseForm。重复调用本方法是无意义的。

#### func (*Request) [ParseMultipartForm](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#777)

```go
func (r *Request) ParseMultipartForm(maxMemory int64) error
```

ParseMultipartForm将请求的主体作为multipart/form-data解析。请求的整个主体都会被解析，得到的文件记录最多maxMemery字节保存在内存，其余部分保存在硬盘的temp文件里。如果必要，ParseMultipartForm会自行调用ParseForm。重复调用本方法是无意义的。

#### func (*Request) [FormValue](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#812)

```go
func (r *Request) FormValue(key string) string
```

FormValue返回key为键查询r.Form字段得到结果[]string切片的第一个值。POST和PUT主体中的同名参数优先于URL查询字符串。如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。

#### func (*Request) [PostFormValue](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#825)

```go
func (r *Request) PostFormValue(key string) string
```

PostFormValue返回key为键查询r.PostForm字段得到结果[]string切片的第一个值。如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。

#### func (*Request) [FormFile](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#837)

```go
func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, error)
```

FormFile返回以key为键查询r.MultipartForm字段得到结果中的第一个文件和它的信息。如果必要，本函数会隐式调用ParseMultipartForm和ParseForm。查询失败会返回ErrMissingFile错误。

#### func (*Request) [MultipartReader](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#295)

```go
func (r *Request) MultipartReader() (*multipart.Reader, error)
```

如果请求是multipart/form-data POST请求，MultipartReader返回一个multipart.Reader接口，否则返回nil和一个错误。使用本函数代替ParseMultipartForm，可以将r.Body作为流处理。

### type [Response](https://github.com/golang/go/blob/master/src/net/http/response.go?name=release#29)

```go
type Response struct {
    Status     string // 例如"200 OK"
    StatusCode int    // 例如200
    Proto      string // 例如"HTTP/1.0"
    ProtoMajor int    // 例如1
    ProtoMinor int    // 例如0
    // Header保管头域的键值对。
    // 如果回复中有多个头的键相同，Header中保存为该键对应用逗号分隔串联起来的这些头的值
    // （参见RFC 2616 Section 4.2）
    // 被本结构体中的其他字段复制保管的头（如ContentLength）会从Header中删掉。
    //
    // Header中的键都是规范化的，参见CanonicalHeaderKey函数
    Header Header
    // Body代表回复的主体。
    // Client类型和Transport类型会保证Body字段总是非nil的，即使回复没有主体或主体长度为0。
    // 关闭主体是调用者的责任。
    // 如果服务端采用"chunked"传输编码发送的回复，Body字段会自动进行解码。
    Body io.ReadCloser
    // ContentLength记录相关内容的长度。
    // 其值为-1表示长度未知（采用chunked传输编码）
    // 除非对应的Request.Method是"HEAD"，其值>=0表示可以从Body读取的字节数
    ContentLength int64
    // TransferEncoding按从最外到最里的顺序列出传输编码，空切片表示"identity"编码。
    TransferEncoding []string
    // Close记录头域是否指定应在读取完主体后关闭连接。（即Connection头）
    // 该值是给客户端的建议，Response.Write方法的ReadResponse函数都不会关闭连接。
    Close bool
    // Trailer字段保存和头域相同格式的trailer键值对，和Header字段相同类型
    Trailer Header
    // Request是用来获取此回复的请求
    // Request的Body字段是nil（因为已经被用掉了）
    // 这个字段是被Client类型发出请求并获得回复后填充的
    Request *Request
    // TLS包含接收到该回复的TLS连接的信息。 对未加密的回复，本字段为nil。
    // 返回的指针是被（同一TLS连接接收到的）回复共享的，不应被修改。
    TLS *tls.ConnectionState
}
```

Response代表一个HTTP请求的回复。

#### func [ReadResponse](https://github.com/golang/go/blob/master/src/net/http/response.go?name=release#116)

```go
func ReadResponse(r *bufio.Reader, req *Request) (*Response, error)
```

ReadResponse从r读取并返回一个HTTP 回复。req参数是可选的，指定该回复对应的请求（即是对该请求的回复）。如果是nil，将假设请求是GET请求。客户端必须在结束resp.Body的读取后关闭它。读取完毕并关闭后，客户端可以检查resp.Trailer字段获取回复的trailer的键值对。（本函数主要用在客户端从下层获取回复）

#### func (*Response) [ProtoAtLeast](https://github.com/golang/go/blob/master/src/net/http/response.go?name=release#184)

```go
func (r *Response) ProtoAtLeast(major, minor int) bool
```

ProtoAtLeast报告该回复使用的HTTP协议版本至少是major.minor。

#### func (*Response) [Cookies](https://github.com/golang/go/blob/master/src/net/http/response.go?name=release#89)

```go
func (r *Response) Cookies() []*Cookie
```

Cookies解析并返回该回复中的Set-Cookie头设置的cookie。

#### func (*Response) [Location](https://github.com/golang/go/blob/master/src/net/http/response.go?name=release#99)

```go
func (r *Response) Location() (*url.URL, error)
```

Location返回该回复的Location头设置的URL。相对地址的重定向会相对于该回复对应的请求来确定绝对地址。如果回复中没有Location头，会返回nil, ErrNoLocation。

#### func (*Response) [Write](https://github.com/golang/go/blob/master/src/net/http/response.go?name=release#203)

```go
func (r *Response) Write(w io.Writer) error
```

Write以有线格式将回复写入w（用于将回复写入下层TCPConn等）。本方法会考虑如下字段：

```go
StatusCode
ProtoMajor
ProtoMinor
Request.Method
TransferEncoding
Trailer
Body
ContentLength
Header（不规范的键名和它对应的值会导致不可预知的行为）
```

Body字段在发送完回复后会被关闭。

### type [ResponseWriter](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#51)

```go
type ResponseWriter interface {
    // Header返回一个Header类型值，该值会被WriteHeader方法发送。
    // 在调用WriteHeader或Write方法后再改变该对象是没有意义的。
    Header() Header
    // WriteHeader该方法发送HTTP回复的头域和状态码。
    // 如果没有被显式调用，第一次调用Write时会触发隐式调用WriteHeader(http.StatusOK)
    // WriterHeader的显式调用主要用于发送错误码。
    WriteHeader(int)
    // Write向连接中写入作为HTTP的一部分回复的数据。
    // 如果被调用时还未调用WriteHeader，本方法会先调用WriteHeader(http.StatusOK)
    // 如果Header中没有"Content-Type"键，
    // 本方法会使用包函数DetectContentType检查数据的前512字节，将返回值作为该键的值。
    Write([]byte) (int, error)
}
```

ResponseWriter接口被HTTP处理器用于构造HTTP回复。

### type [Flusher](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#79)

```go
type Flusher interface {
    // Flush将缓冲中的所有数据发送到客户端
    Flush()
}
```

HTTP处理器ResponseWriter接口参数的下层如果实现了Flusher接口，可以让HTTP处理器将缓冲中的数据发送到客户端。

注意：即使ResponseWriter接口的下层支持Flush方法，如果客户端是通过HTTP代理连接的，缓冲中的数据也可能直到回复完毕才被传输到客户端。

### type [CloseNotifier](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#100)

```go
type CloseNotifier interface {
    // CloseNotify返回一个通道，该通道会在客户端连接丢失时接收到唯一的值
    CloseNotify() <-chan bool
}
```

HTTP处理器ResponseWriter接口参数的下层如果实现了CloseNotifier接口，可以让用户检测下层的连接是否停止。如果客户端在回复准备好之前关闭了连接，该机制可以用于取消服务端耗时较长的操作。

### type [Hijacker](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#86)

```go
type Hijacker interface {
    // Hijack让调用者接管连接，返回连接和关联到该连接的一个缓冲读写器。
    // 调用本方法后，HTTP服务端将不再对连接进行任何操作，
    // 调用者有责任管理、关闭返回的连接。
    Hijack() (net.Conn, *bufio.ReadWriter, error)
}
```

HTTP处理器ResponseWriter接口参数的下层如果实现了Hijacker接口，可以让HTTP处理器接管该连接。

Example

```go
http.HandleFunc("/hijack", func(w http.ResponseWriter, r *http.Request) {
    hj, ok := w.(http.Hijacker)
    if !ok {
        http.Error(w, "webserver doesn't support hijacking", http.StatusInternalServerError)
        return
    }
    conn, bufrw, err := hj.Hijack()
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    // Don't forget to close the connection:
    defer conn.Close()
    bufrw.WriteString("Now we're speaking raw TCP. Say hi: ")
    bufrw.Flush()
    s, err := bufrw.ReadString('\n')
    if err != nil {
        log.Printf("error reading string: %v", err)
        return
    }
    fmt.Fprintf(bufrw, "You said: %q\nBye.\n", s)
    bufrw.Flush()
})
```

### type [RoundTripper](https://github.com/golang/go/blob/master/src/net/http/client.go?name=release#82)

```go
type RoundTripper interface {
    // RoundTrip执行单次HTTP事务，接收并发挥请求req的回复。
    // RoundTrip不应试图解析/修改得到的回复。
    // 尤其要注意，只要RoundTrip获得了一个回复，不管该回复的HTTP状态码如何，
    // 它必须将返回值err设置为nil。
    // 非nil的返回值err应该留给获取回复失败的情况。
    // 类似的，RoundTrip不能试图管理高层次的细节，如重定向、认证、cookie。
    //
    // 除了从请求的主体读取并关闭主体之外，RoundTrip不应修改请求，包括（请求的）错误。
    // RoundTrip函数接收的请求的URL和Header字段可以保证是（被）初始化了的。
    RoundTrip(*Request) (*Response, error)
}
```

RoundTripper接口是具有执行单次HTTP事务的能力（接收指定请求的回复）的接口。

RoundTripper接口的类型必须可以安全的被多线程同时使用。

### type [Transport](https://github.com/golang/go/blob/master/src/net/http/transport.go?name=release#49)

```go
type Transport struct {
    // Proxy指定一个对给定请求返回代理的函数。
    // 如果该函数返回了非nil的错误值，请求的执行就会中断并返回该错误。
    // 如果Proxy为nil或返回nil的*URL置，将不使用代理。
    Proxy func(*Request) (*url.URL, error)
    // Dial指定创建TCP连接的拨号函数。如果Dial为nil，会使用net.Dial。
    Dial func(network, addr string) (net.Conn, error)
    // TLSClientConfig指定用于tls.Client的TLS配置信息。
    // 如果该字段为nil，会使用默认的配置信息。
    TLSClientConfig *tls.Config
    // TLSHandshakeTimeout指定等待TLS握手完成的最长时间。零值表示不设置超时。
    TLSHandshakeTimeout time.Duration
    // 如果DisableKeepAlives为真，会禁止不同HTTP请求之间TCP连接的重用。
    DisableKeepAlives bool
    // 如果DisableCompression为真，会禁止Transport在请求中没有Accept-Encoding头时，
    // 主动添加"Accept-Encoding: gzip"头，以获取压缩数据。
    // 如果Transport自己请求gzip并得到了压缩后的回复，它会主动解压缩回复的主体。
    // 但如果用户显式的请求gzip压缩数据，Transport是不会主动解压缩的。
    DisableCompression bool
    // 如果MaxIdleConnsPerHost!=0，会控制每个主机下的最大闲置连接。
    // 如果MaxIdleConnsPerHost==0，会使用DefaultMaxIdleConnsPerHost。
    MaxIdleConnsPerHost int
    // ResponseHeaderTimeout指定在发送完请求（包括其可能的主体）之后，
    // 等待接收服务端的回复的头域的最大时间。零值表示不设置超时。
    // 该时间不包括获取回复主体的时间。
    ResponseHeaderTimeout time.Duration
    // 内含隐藏或非导出字段
}
```

Transport类型实现了RoundTripper接口，支持http、https和http/https代理。Transport类型可以缓存连接以在未来重用。

```go
var DefaultTransport RoundTripper = &Transport{
    Proxy: ProxyFromEnvironment,
    Dial: (&net.Dialer{
        Timeout:   30 * time.Second,
        KeepAlive: 30 * time.Second,
    }).Dial,
    TLSHandshakeTimeout: 10 * time.Second,
}
```

DefaultTransport是被包变量DefaultClient使用的默认RoundTripper接口。它会根据需要创建网络连接，并缓存以便在之后的请求中重用这些连接。它使用环境变量$HTTP_PROXY和$NO_PROXY（或$http_proxy和$no_proxy）指定的HTTP代理。

#### func (*Transport) [RegisterProtocol](https://github.com/golang/go/blob/master/src/net/http/transport.go?name=release#217)

```go
func (t *Transport) RegisterProtocol(scheme string, rt RoundTripper)
```

RegisterProtocol注册一个新的名为scheme的协议。t会将使用scheme协议的请求转交给rt。rt有责任模拟HTTP请求的语义。

RegisterProtocol可以被其他包用于提供"ftp"或"file"等协议的实现。

#### func (*Transport) [RoundTrip](https://github.com/golang/go/blob/master/src/net/http/transport.go?name=release#164)

```go
func (t *Transport) RoundTrip(req *Request) (resp *Response, err error)
```

RoundTrip方法实现了RoundTripper接口。

高层次的HTTP客户端支持（如管理cookie和重定向）请参见Get、Post等函数和Client类型。

#### func (*Transport) [CloseIdleConnections](https://github.com/golang/go/blob/master/src/net/http/transport.go?name=release#236)

```go
func (t *Transport) CloseIdleConnections()
```

CloseIdleConnections关闭所有之前的请求建立但目前处于闲置状态的连接。本方法不会中断正在使用的连接。

#### func (*Transport) [CancelRequest](https://github.com/golang/go/blob/master/src/net/http/transport.go?name=release#251)

```go
func (t *Transport) CancelRequest(req *Request)
```

CancelRequest通过关闭请求所在的连接取消一个执行中的请求。

### type [Client](https://github.com/golang/go/blob/master/src/net/http/client.go?name=release#35)

```go
type Client struct {
    // Transport指定执行独立、单次HTTP请求的机制。
    // 如果Transport为nil，则使用DefaultTransport。
    Transport RoundTripper
    // CheckRedirect指定处理重定向的策略。
    // 如果CheckRedirect不为nil，客户端会在执行重定向之前调用本函数字段。
    // 参数req和via是将要执行的请求和已经执行的请求（切片，越新的请求越靠后）。
    // 如果CheckRedirect返回一个错误，本类型的Get方法不会发送请求req，
    // 而是返回之前得到的最后一个回复和该错误。（包装进url.Error类型里）
    //
    // 如果CheckRedirect为nil，会采用默认策略：连续10此请求后停止。
    CheckRedirect func(req *Request, via []*Request) error
    // Jar指定cookie管理器。
    // 如果Jar为nil，请求中不会发送cookie，回复中的cookie会被忽略。
    Jar CookieJar
    // Timeout指定本类型的值执行请求的时间限制。
    // 该超时限制包括连接时间、重定向和读取回复主体的时间。
    // 计时器会在Head、Get、Post或Do方法返回后继续运作并在超时后中断回复主体的读取。
    //
    // Timeout为零值表示不设置超时。
    //
    // Client实例的Transport字段必须支持CancelRequest方法，
    // 否则Client会在试图用Head、Get、Post或Do方法执行请求时返回错误。
    // 本类型的Transport字段默认值（DefaultTransport）支持CancelRequest方法。
    Timeout time.Duration
}
```

Client类型代表HTTP客户端。它的零值（DefaultClient）是一个可用的使用DefaultTransport的客户端。

Client的Transport字段一般会含有内部状态（缓存TCP连接），因此Client类型值应尽量被重用而不是每次需要都创建新的。Client类型值可以安全的被多个go程同时使用。

Client类型的层次比RoundTripper接口（如Transport）高，还会管理HTTP的cookie和重定向等细节。

#### func (*Client) [Do](https://github.com/golang/go/blob/master/src/net/http/client.go?name=release#148)

```go
func (c *Client) Do(req *Request) (resp *Response, err error)
```

Do方法发送请求，返回HTTP回复。它会遵守客户端c设置的策略（如重定向、cookie、认证）。

如果客户端的策略（如重定向）返回错误或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。

如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。如果返回值resp的主体未关闭，c下层的RoundTripper接口（一般为Transport类型）可能无法重用resp主体下层保持的TCP连接去执行之后的请求。

请求的主体，如果非nil，会在执行后被c.Transport关闭，即使出现错误。

一般应使用Get、Post或PostForm方法代替Do方法。

#### func (*Client) [Head](https://github.com/golang/go/blob/master/src/net/http/client.go?name=release#462)

```go
func (c *Client) Head(url string) (resp *Response, err error)
```

Head向指定的URL发出一个HEAD请求，如果回应的状态码如下，Head会在调用c.CheckRedirect后执行重定向：

```
301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
```

#### func (*Client) [Get](https://github.com/golang/go/blob/master/src/net/http/client.go?name=release#270)

```go
func (c *Client) Get(url string) (resp *Response, err error)
```

Get向指定的URL发出一个GET请求，如果回应的状态码如下，Get会在调用c.CheckRedirect后执行重定向：

```
301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
```

如果c.CheckRedirect执行失败或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。

#### func (*Client) [Post](https://github.com/golang/go/blob/master/src/net/http/client.go?name=release#411)

```go
func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error)
```

Post向指定的URL发出一个POST请求。bodyType为POST数据的类型， body为POST数据，作为请求的主体。如果参数body实现了io.Closer接口，它会在发送请求后被关闭。调用者有责任在读取完返回值resp的主体后关闭它。

#### func (*Client) [PostForm](https://github.com/golang/go/blob/master/src/net/http/client.go?name=release#436)

```go
func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)
```

PostForm向指定的URL发出一个POST请求，url.Values类型的data会被编码为请求的主体。POST数据的类型一般会设为"application/x-www-form-urlencoded"。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。

### type [Handler](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#45)

```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

实现了Handler接口的对象可以注册到HTTP服务端，为特定的路径及其子树提供服务。

ServeHTTP应该将回复的头域和数据写入ResponseWriter接口然后返回。返回标志着该请求已经结束，HTTP服务端可以转移向该连接上的下一个请求。

#### func [NotFoundHandler](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1253)

```go
func NotFoundHandler() Handler
```

NotFoundHandler返回一个简单的请求处理器，该处理器会对每个请求都回复"404 page not found"。

#### func [RedirectHandler](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1360)

```go
func RedirectHandler(url string, code int) Handler
```

RedirectHandler返回一个请求处理器，该处理器会对每个请求都使用状态码code重定向到网址url。

#### func [TimeoutHandler](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1860)

```go
func TimeoutHandler(h Handler, dt time.Duration, msg string) Handler
```

TimeoutHandler返回一个采用指定时间限制的请求处理器。

返回的Handler会调用h.ServeHTTP去处理每个请求，但如果某一次调用耗时超过了时间限制，该处理器会回复请求状态码503 Service Unavailable，并将msg作为回复的主体（如果msg为空字符串，将发送一个合理的默认信息）。在超时后，h对它的ResponseWriter接口参数的写入操作会返回ErrHandlerTimeout。

#### func [StripPrefix](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1260)

```go
func StripPrefix(prefix string, h Handler) Handler
```

StripPrefix返回一个处理器，该处理器会将请求的URL.Path字段中给定前缀prefix去除后再交由h处理。StripPrefix会向URL.Path字段中没有给定前缀的请求回复404 page not found。

Example

```go
// To serve a directory on disk (/tmp) under an alternate URL
// path (/tmpfiles/), use StripPrefix to modify the request
// URL's path before the FileServer sees it:
http.Handle("/tmpfiles/", http.StripPrefix("/tmpfiles/", http.FileServer(http.Dir("/tmp"))))
```

### type [HandlerFunc](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1231)

```go
type HandlerFunc func(ResponseWriter, *Request)
```

HandlerFunc type是一个适配器，通过类型转换让我们可以将普通的函数作为HTTP处理器使用。如果f是一个具有适当签名的函数，HandlerFunc(f)通过调用f实现了Handler接口。

#### func (HandlerFunc) [ServeHTTP](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1234)

```go
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)
```

ServeHTTP方法会调用f(w, r)

### type [ServeMux](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1391)

```go
type ServeMux struct {
    // 内含隐藏或非导出字段
}
```

ServeMux类型是HTTP请求的多路转接器。它会将每一个接收的请求的URL与一个注册模式的列表进行匹配，并调用和URL最匹配的模式的处理器。

模式是固定的、由根开始的路径，如"/favicon.ico"，或由根开始的子树，如"/images/"（注意结尾的斜杠）。较长的模式优先于较短的模式，因此如果模式"/images/"和"/images/thumbnails/"都注册了处理器，后一个处理器会用于路径以"/images/thumbnails/"开始的请求，前一个处理器会接收到其余的路径在"/images/"子树下的请求。

注意，因为以斜杠结尾的模式代表一个由根开始的子树，模式"/"会匹配所有的未被其他注册的模式匹配的路径，而不仅仅是路径"/"。

模式也能（可选地）以主机名开始，表示只匹配该主机上的路径。指定主机的模式优先于一般的模式，因此一个注册了两个模式"/codesearch"和"codesearch.google.com/"的处理器不会接管目标为"<http://www.google.com/>"的请求。

ServeMux还会注意到请求的URL路径的无害化，将任何路径中包含"."或".."元素的请求重定向到等价的没有这两种元素的URL。（参见path.Clean函数）

#### func [NewServeMux](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1404)

```go
func NewServeMux() *ServeMux
```

NewServeMux创建并返回一个新的*ServeMux

#### func (*ServeMux) [Handle](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1516)

```go
func (mux *ServeMux) Handle(pattern string, handler Handler)
```

Handle注册HTTP处理器handler和对应的模式pattern。如果该模式已经注册有一个处理器，Handle会panic。

Example

```go
mux := http.NewServeMux()
mux.Handle("/api/", apiHandler{})
mux.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {
    // The "/" pattern matches everything, so we need to check
    // that we're at the root here.
    if req.URL.Path != "/" {
        http.NotFound(w, req)
        return
    }
    fmt.Fprintf(w, "Welcome to the home page!")
})
```

#### func (*ServeMux) [HandleFunc](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1554)

```go
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))
```

HandleFunc注册一个处理器函数handler和对应的模式pattern。

#### func (*ServeMux) [Handler](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1468)

```go
func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)
```

Handler根据r.Method、r.Host和r.URL.Path等数据，返回将用于处理该请求的HTTP处理器。它总是返回一个非nil的处理器。如果路径不是它的规范格式，将返回内建的用于重定向到等价的规范路径的处理器。

Handler也会返回匹配该请求的的已注册模式；在内建重定向处理器的情况下，pattern会在重定向后进行匹配。如果没有已注册模式可以应用于该请求，本方法将返回一个内建的"404 page not found"处理器和一个空字符串模式。

#### func (*ServeMux) [ServeHTTP](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1502)

```go
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)
```

ServeHTTP将请求派遣到与请求的URL最匹配的模式对应的处理器。

### type [Server](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1581)

```go
type Server struct {
    Addr           string        // 监听的TCP地址，如果为空字符串会使用":http"
    Handler        Handler       // 调用的处理器，如为nil会调用http.DefaultServeMux
    ReadTimeout    time.Duration // 请求的读取操作在超时前的最大持续时间
    WriteTimeout   time.Duration // 回复的写入操作在超时前的最大持续时间
    MaxHeaderBytes int           // 请求的头域最大长度，如为0则用DefaultMaxHeaderBytes
    TLSConfig      *tls.Config   // 可选的TLS配置，用于ListenAndServeTLS方法
    // TLSNextProto（可选地）指定一个函数来在一个NPN型协议升级出现时接管TLS连接的所有权。
    // 映射的键为商谈的协议名；映射的值为函数，该函数的Handler参数应处理HTTP请求，
    // 并且初始化Handler.ServeHTTP的*Request参数的TLS和RemoteAddr字段（如果未设置）。
    // 连接在函数返回时会自动关闭。
    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)
    // ConnState字段指定一个可选的回调函数，该函数会在一个与客户端的连接改变状态时被调用。
    // 参见ConnState类型和相关常数获取细节。
    ConnState func(net.Conn, ConnState)
    // ErrorLog指定一个可选的日志记录器，用于记录接收连接时的错误和处理器不正常的行为。
    // 如果本字段为nil，日志会通过log包的标准日志记录器写入os.Stderr。
    ErrorLog *log.Logger
    // 内含隐藏或非导出字段
}
```

Server类型定义了运行HTTP服务端的参数。Server的零值是合法的配置。

#### func (*Server) [SetKeepAlivesEnabled](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1733)

```go
func (s *Server) SetKeepAlivesEnabled(v bool)
```

SetKeepAlivesEnabled控制是否允许HTTP闲置连接重用（keep-alive）功能。默认该功能总是被启用的。只有资源非常紧张的环境或者服务端在关闭进程中时，才应该关闭该功能。

#### func (*Server) [Serve](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1694)

```go
func (srv *Server) Serve(l net.Listener) error
```

Serve会接手监听器l收到的每一个连接，并为每一个连接创建一个新的服务go程。该go程会读取请求，然后调用srv.Handler回复请求。

#### func (*Server) [ListenAndServe](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1679)

```go
func (srv *Server) ListenAndServe() error
```

ListenAndServe监听srv.Addr指定的TCP地址，并且会调用Serve方法接收到的连接。如果srv.Addr为空字符串，会使用":http"。

#### func (*Server) [ListenAndServeTLS](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1823)

```go
func (srv *Server) ListenAndServeTLS(certFile, keyFile string) error
```

ListenAndServeTLS监听srv.Addr确定的TCP地址，并且会调用Serve方法处理接收到的连接。必须提供证书文件和对应的私钥文件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使用":https"。

### type [File](https://github.com/golang/go/blob/master/src/net/http/fs.go?name=release#58)

```go
type File interface {
    io.Closer
    io.Reader
    Readdir(count int) ([]os.FileInfo, error)
    Seek(offset int64, whence int) (int64, error)
    Stat() (os.FileInfo, error)
}
```

File是被FileSystem接口的Open方法返回的接口类型，可以被FileServer等函数用于文件访问服务。

该接口的方法的行为应该和*os.File类型的同名方法相同。

### type [FileSystem](https://github.com/golang/go/blob/master/src/net/http/fs.go?name=release#50)

```go
type FileSystem interface {
    Open(name string) (File, error)
}
```

FileSystem接口实现了对一系列命名文件的访问。文件路径的分隔符为'/'，不管主机操作系统的惯例如何。

### type [Dir](https://github.com/golang/go/blob/master/src/net/http/fs.go?name=release#29)

```go
type Dir string
```

Dir使用限制到指定目录树的本地文件系统实现了http.FileSystem接口。空Dir被视为"."，即代表当前目录。

#### func (Dir) [Open](https://github.com/golang/go/blob/master/src/net/http/fs.go?name=release#31)

```go
func (d Dir) Open(name string) (File, error)
```

### func [NewFileTransport](https://github.com/golang/go/blob/master/src/net/http/filetransport.go?name=release#30)

```go
func NewFileTransport(fs FileSystem) RoundTripper
```

NewFileTransport返回一个RoundTripper接口，使用FileSystem接口fs提供文件访问服务。 返回的RoundTripper接口会忽略接收的请求的URL主机及其他绝大多数属性。

NewFileTransport函数的典型使用情况是给Transport类型的值注册"file"协议，如下所示：

```go
t := &http.Transport{}
t.RegisterProtocol("file", http.NewFileTransport(http.Dir("/")))
c := &http.Client{Transport: t}
res, err := c.Get("file:///etc/passwd")
...
```

### func [FileServer](https://github.com/golang/go/blob/master/src/net/http/fs.go?name=release#435)

```go
func FileServer(root FileSystem) Handler
```

FileServer返回一个使用FileSystem接口root提供文件访问服务的HTTP处理器。要使用操作系统的FileSystem接口实现，可使用http.Dir：

```go
http.Handle("/", http.FileServer(http.Dir("/tmp")))
```

Example

```go
// Simple static webserver:
log.Fatal(http.ListenAndServe(":8080", http.FileServer(http.Dir("/usr/share/doc"))))
```

Example (StripPrefix)

```go
// To serve a directory on disk (/tmp) under an alternate URL
// path (/tmpfiles/), use StripPrefix to modify the request
// URL's path before the FileServer sees it:
http.Handle("/tmpfiles/", http.StripPrefix("/tmpfiles/", http.FileServer(http.Dir("/tmp"))))
```

### func [ProxyURL](https://github.com/golang/go/blob/master/src/net/http/transport.go?name=release#140)

```go
func ProxyURL(fixedURL *url.URL) func(*Request) (*url.URL, error)
```

ProxyURL返回一个代理函数（用于Transport类型），该函数总是返回同一个URL。

### func [ProxyFromEnvironment](https://github.com/golang/go/blob/master/src/net/http/transport.go?name=release#115)

```go
func ProxyFromEnvironment(req *Request) (*url.URL, error)
```

ProxyFromEnvironment使用环境变量$HTTP_PROXY和$NO_PROXY(或$http_proxy和$no_proxy)的配置返回用于req的代理。如果代理环境不合法将返回错误；如果环境未设定代理或者给定的request不应使用代理时，将返回(nil, nil)；如果req.URL.Host字段是"localhost"（可以有端口号，也可以没有），也会返回(nil, nil)。

### func [SetCookie](https://github.com/golang/go/blob/master/src/net/http/cookie.go?name=release#129)

```go
func SetCookie(w ResponseWriter, cookie *Cookie)
```

SetCookie在w的头域中添加Set-Cookie头，该HTTP头的值为cookie。

### func [Redirect](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1276)

```go
func Redirect(w ResponseWriter, r *Request, urlStr string, code int)
```

Redirect回复请求一个重定向地址urlStr和状态码code。该重定向地址可以是相对于请求r的相对地址。

### func [NotFound](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1249)

```go
func NotFound(w ResponseWriter, r *Request)
```

NotFound回复请求404状态码（not found：目标未发现）。

### func [Error](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1242)

```go
func Error(w ResponseWriter, error string, code int)
```

Error使用指定的错误信息和状态码回复请求，将数据写入w。错误信息必须是明文。

### func [ServeContent](https://github.com/golang/go/blob/master/src/net/http/fs.go?name=release#113)

```go
func ServeContent(w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)
```

ServeContent使用提供的ReadSeeker的内容回复请求。ServeContent比起io.Copy函数的主要优点，是可以处理范围类请求（只要一部分内容）、设置MIME类型，处理If-Modified-Since请求。

如果未设定回复的Content-Type头，本函数首先会尝试从name的文件扩展名推断数据类型；如果失败，会用读取content的第1块数据并提供给DetectContentType推断类型；之后会设置Content-Type头。参数name不会用于别的地方，甚至于它可以是空字符串，也永远不会发送到回复里。

如果modtime不是Time零值，函数会在回复的头域里设置Last-Modified头。如果请求的头域包含If-Modified-Since头，本函数会使用modtime参数来确定是否应该发送内容。如果调用者设置了w的ETag头，ServeContent会使用它处理包含If-Range头和If-None-Match头的请求。

参数content的Seek方法必须有效：函数使用Seek来确定它的大小。

注意：本包File接口和*os.File类型都实现了io.ReadSeeker接口。

### func [ServeFile](https://github.com/golang/go/blob/master/src/net/http/fs.go?name=release#419)

```go
func ServeFile(w ResponseWriter, r *Request, name string)
```

ServeFile回复请求name指定的文件或者目录的内容。

### func [MaxBytesReader](https://github.com/golang/go/blob/master/src/net/http/request.go?name=release#637)

```go
func MaxBytesReader(w ResponseWriter, r io.ReadCloser, n int64) io.ReadCloser
```

MaxBytesReader类似io.LimitReader，但它是用来限制接收到的请求的Body的大小的。不同于io.LimitReader，本函数返回一个ReadCloser，返回值的Read方法在读取的数据超过大小限制时会返回非EOF错误，其Close方法会关闭下层的io.ReadCloser接口r。

MaxBytesReader预防客户端因为意外或者蓄意发送的“大”请求，以避免尺寸过大的请求浪费服务端资源。

### func [Head](https://github.com/golang/go/blob/master/src/net/http/client.go?name=release#450)

```go
func Head(url string) (resp *Response, err error)
```

Head向指定的URL发出一个HEAD请求，如果回应的状态码如下，Head会在调用c.CheckRedirect后执行重定向：

```go
301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
```

Head是对包变量DefaultClient的Head方法的包装。

### func [Get](https://github.com/golang/go/blob/master/src/net/http/client.go?name=release#251)

```go
func Get(url string) (resp *Response, err error)
```

Get向指定的URL发出一个GET请求，如果回应的状态码如下，Get会在调用c.CheckRedirect后执行重定向：

```go
301 (Moved Permanently)
302 (Found)
303 (See Other)
307 (Temporary Redirect)
```

如果c.CheckRedirect执行失败或存在HTTP协议错误时，本方法将返回该错误；如果回应的状态码不是2xx，本方法并不会返回错误。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。

Get是对包变量DefaultClient的Get方法的包装。

Example

```go
res, err := http.Get("http://www.google.com/robots.txt")
if err != nil {
    log.Fatal(err)
}
robots, err := ioutil.ReadAll(res.Body)
res.Body.Close()
if err != nil {
    log.Fatal(err)
}
fmt.Printf("%s", robots)
```

### func [Post](https://github.com/golang/go/blob/master/src/net/http/client.go?name=release#401)

```go
func Post(url string, bodyType string, body io.Reader) (resp *Response, err error)
```

Post向指定的URL发出一个POST请求。bodyType为POST数据的类型， body为POST数据，作为请求的主体。如果参数body实现了io.Closer接口，它会在发送请求后被关闭。调用者有责任在读取完返回值resp的主体后关闭它。

Post是对包变量DefaultClient的Post方法的包装。

### func [PostForm](https://github.com/golang/go/blob/master/src/net/http/client.go?name=release#427)

```go
func PostForm(url string, data url.Values) (resp *Response, err error)
```

PostForm向指定的URL发出一个POST请求，url.Values类型的data会被编码为请求的主体。如果返回值err为nil，resp.Body总是非nil的，调用者应该在读取完resp.Body后关闭它。

PostForm是对包变量DefaultClient的PostForm方法的包装。

### func [Handle](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1561)

```go
func Handle(pattern string, handler Handler)
```

Handle注册HTTP处理器handler和对应的模式pattern（注册到DefaultServeMux）。如果该模式已经注册有一个处理器，Handle会panic。ServeMux的文档解释了模式的匹配机制。

### func [HandleFunc](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1566)

```go
func HandleFunc(pattern string, handler func(ResponseWriter, *Request))
```

HandleFunc注册一个处理器函数handler和对应的模式pattern（注册到DefaultServeMux）。ServeMux的文档解释了模式的匹配机制。

### func [Serve](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1574)

```go
func Serve(l net.Listener, handler Handler) error
```

Serve会接手监听器l收到的每一个连接，并为每一个连接创建一个新的服务go程。该go程会读取请求，然后调用handler回复请求。handler参数一般会设为nil，此时会使用DefaultServeMux。

### func [ListenAndServe](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1776)

```go
func ListenAndServe(addr string, handler Handler) error
```

ListenAndServe监听TCP地址addr，并且会使用handler参数调用Serve函数处理接收到的连接。handler参数一般会设为nil，此时会使用DefaultServeMux。

一个简单的服务端例子：

```go
package main
import (
	"io"
	"net/http"
	"log"
)
// hello world, the web server
func HelloServer(w http.ResponseWriter, req *http.Request) {
	io.WriteString(w, "hello, world!\n")
}
func main() {
	http.HandleFunc("/hello", HelloServer)
	err := http.ListenAndServe(":12345", nil)
	if err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}
```

### func [ListenAndServeTLS](https://github.com/golang/go/blob/master/src/net/http/server.go?name=release#1809)

```go
func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) error
```

ListenAndServeTLS函数和ListenAndServe函数的行为基本一致，除了它期望HTTPS连接之外。此外，必须提供证书文件和对应的私钥文件。如果证书是由权威机构签发的，certFile参数必须是顺序串联的服务端证书和CA证书。如果srv.Addr为空字符串，会使用":https"。

一个简单的服务端例子：

```go
import (
	"log"
	"net/http"
)
func handler(w http.ResponseWriter, req *http.Request) {
	w.Header().Set("Content-Type", "text/plain")
	w.Write([]byte("This is an example server.\n"))
}
func main() {
	http.HandleFunc("/", handler)
	log.Printf("About to listen on 10443. Go to https://127.0.0.1:10443/")
	err := http.ListenAndServeTLS(":10443", "cert.pem", "key.pem", nil)
	if err != nil {
		log.Fatal(err)
	}
}
```

程序员可以使用crypto/tls包的generate_cert.go文件来生成cert.pem和key.pem两个文件。

``

# encoding/hex包

package hex

```go
import "encoding/hex"
```

hex包实现了16进制字符表示的编解码。

### Variables

```go
var ErrLength = errors.New("encoding/hex: odd length hex string")
```

解码一个长度为奇数的切片时，将返回此错误。

### type [InvalidByteError](https://github.com/golang/go/blob/master/src/encoding/hex/hex.go?name=release#37)

```go
type InvalidByteError byte
```

描述一个hex编码字符串中的非法字符。

#### func (InvalidByteError) [Error](https://github.com/golang/go/blob/master/src/encoding/hex/hex.go?name=release#39)

```go
func (e InvalidByteError) Error() string
```

### func [DecodedLen](https://github.com/golang/go/blob/master/src/encoding/hex/hex.go?name=release#43)

```go
func DecodedLen(x int) int
```

长度x的编码数据解码后的明文数据的长度

### func [Decode](https://github.com/golang/go/blob/master/src/encoding/hex/hex.go?name=release#49)

```go
func Decode(dst, src []byte) (int, error)
```

将src解码为DecodedLen(len(src))字节，返回实际写入dst的字节数；如遇到非法字符，返回描述错误的error。

### func [DecodeString](https://github.com/golang/go/blob/master/src/encoding/hex/hex.go?name=release#91)

```go
func DecodeString(s string) ([]byte, error)
```

返回hex编码的字符串s代表的数据。

### func [EncodedLen](https://github.com/golang/go/blob/master/src/encoding/hex/hex.go?name=release#18)

```go
func EncodedLen(n int) int
```

长度x的明文数据编码后的编码数据的长度。

### func [Encode](https://github.com/golang/go/blob/master/src/encoding/hex/hex.go?name=release#24)

```go
func Encode(dst, src []byte) int
```

将src的数据解码为EncodedLen(len(src))字节，返回实际写入dst的字节数：EncodedLen(len(src))。

### func [EncodeToString](https://github.com/golang/go/blob/master/src/encoding/hex/hex.go?name=release#84)

```go
func EncodeToString(src []byte) string
```

将数据src编码为字符串s。

### func [Dump](https://github.com/golang/go/blob/master/src/encoding/hex/hex.go?name=release#103)

```go
func Dump(data []byte) string
```

返回给定数据的hex dump格式的字符串，这个字符串与控制台下`hexdump -C`对该数据的输出是一致的。

### func [Dumper](https://github.com/golang/go/blob/master/src/encoding/hex/hex.go?name=release#114)

```go
func Dumper(w io.Writer) io.WriteCloser
```

返回一个io.WriteCloser接口，将写入的数据的hex dump格式写入w，具体格式为'hexdump -C'。

# encoding/binary包

package binary

```go
import "encoding/binary"
```

binary包实现了简单的数字与字节序列的转换以及变长值的编解码。

数字翻译为定长值来读写，一个定长值，要么是固定长度的数字类型（int8, uint8, int16, float32, complex64, ...）或者只包含定长值的结构体或者数组。

变长值是使用一到多个字节编码整数的方法，绝对值较小的数字会占用较少的字节数。详情请参见：<http://code.google.com/apis/protocolbuffers/docs/encoding.html>。

本包相对于效率更注重简单。如果需要高效的序列化，特别是数据结构较复杂的，请参见更高级的解决方法，例如encoding/gob包，或者采用协议缓存。

### Constants

```go
const (
    MaxVarintLen16 = 3
    MaxVarintLen32 = 5
    MaxVarintLen64 = 10
)
```

变长编码N位整数的最大字节数。

### Variables

```go
var BigEndian bigEndian
```

大端字节序的实现。

```go
var LittleEndian littleEndian
```

小端字节序的实现。

### type [ByteOrder](https://github.com/golang/go/blob/master/src/encoding/binary/binary.go?name=release#32)

```go
type ByteOrder interface {
    Uint16([]byte) uint16
    Uint32([]byte) uint32
    Uint64([]byte) uint64
    PutUint16([]byte, uint16)
    PutUint32([]byte, uint32)
    PutUint64([]byte, uint64)
    String() string
}
```

ByteOrder规定了如何将字节序列和 16、32或64比特的无符号整数互相转化。

### func [Size](https://github.com/golang/go/blob/master/src/encoding/binary/binary.go?name=release#339)

```go
func Size(v interface{}) int
```

返回v编码后会占用多少字节，注意v必须是定长值、定长值的切片、定长值的指针。

### func [Uvarint](https://github.com/golang/go/blob/master/src/encoding/binary/varint.go?name=release#60)

```go
func Uvarint(buf []byte) (uint64, int)
```

从buf解码一个uint64，返回该数字和读取的字节长度，如果发生了错误，该数字为0而读取长度n返回值的意思是：

```go
	n == 0: buf不完整，太短了
	n  < 0: 值太大了，64比特装不下（溢出），-n为读取的字节数
```

### func [Varint](https://github.com/golang/go/blob/master/src/encoding/binary/varint.go?name=release#94)

```go
func Varint(buf []byte) (int64, int)
```

从buf解码一个int64，返回该数字和读取的字节长度，如果发生了错误，该数字为0而读取长度n返回值的意思是：

```go
	n == 0: buf不完整，太短了
	n  < 0: 值太大了，64比特装不下（溢出），-n为读取的字节数
```

### func [ReadUvarint](https://github.com/golang/go/blob/master/src/encoding/binary/varint.go?name=release#106)

```go
func ReadUvarint(r io.ByteReader) (uint64, error)
```

从r读取一个编码后的无符号整数，并返回该整数。

### func [ReadVarint](https://github.com/golang/go/blob/master/src/encoding/binary/varint.go?name=release#126)

```go
func ReadVarint(r io.ByteReader) (int64, error)
```

从r读取一个编码后的有符号整数，并返回该整数。

### func [PutUvarint](https://github.com/golang/go/blob/master/src/encoding/binary/varint.go?name=release#41)

```go
func PutUvarint(buf []byte, x uint64) int
```

将一个uint64数字编码写入buf并返回写入的长度，如果buf太小，则会panic。

### func [PutVarint](https://github.com/golang/go/blob/master/src/encoding/binary/varint.go?name=release#78)

```go
func PutVarint(buf []byte, x int64) int
```

将一个int64数字编码写入buf并返回写入的长度，如果buf太小，则会panic。

### func [Read](https://github.com/golang/go/blob/master/src/encoding/binary/binary.go?name=release#137)

```go
func Read(r io.Reader, order ByteOrder, data interface{}) error
```

从r中读取binary编码的数据并赋给data，data必须是一个指向定长值的指针或者定长值的切片。从r读取的字节使用order指定的字节序解码并写入data的字段里当写入结构体是，名字中有'_'的字段会被跳过，这些字段可用于填充（内存空间）。

Example

```go
var pi float64
b := []byte{0x18, 0x2d, 0x44, 0x54, 0xfb, 0x21, 0x09, 0x40}
buf := bytes.NewReader(b)
err := binary.Read(buf, binary.LittleEndian, &pi)
if err != nil {
    fmt.Println("binary.Read failed:", err)
}
fmt.Print(pi)
```

Output:

```go
3.141592653589793
```

### func [Write](https://github.com/golang/go/blob/master/src/encoding/binary/binary.go?name=release#230)

```go
func Write(w io.Writer, order ByteOrder, data interface{}) error
```

将data的binary编码格式写入w，data必须是定长值、定长值的切片、定长值的指针。order指定写入数据的字节序，写入结构体时，名字中有'_'的字段会置为0。

Example

```go
buf := new(bytes.Buffer)
var pi float64 = math.Pi
err := binary.Write(buf, binary.LittleEndian, pi)
if err != nil {
    fmt.Println("binary.Write failed:", err)
}
fmt.Printf("% x", buf.Bytes())
```

Output:

```go
18 2d 44 54 fb 21 09 40
```

Example (Multi)

```go
buf := new(bytes.Buffer)
var data = []interface{}{
    uint16(61374),
    int8(-54),
    uint8(254),
}
for _, v := range data {
    err := binary.Write(buf, binary.LittleEndian, v)
    if err != nil {
        fmt.Println("binary.Write failed:", err)
    }
}
fmt.Printf("%x", buf.Bytes())
```

Output:

```go
beefcafe
```

# crypto/md5包

package md5

```go
import "crypto/md5"
```

md5包实现了MD5哈希算法，参见[RFC 1321](http://tools.ietf.org/html/rfc1321)

### Constants

```go
const BlockSize = 64
```

MD5字节块大小。

```go
const Size = 16
```

MD5校验和字节数。

### func [Sum](https://github.com/golang/go/blob/master/src/crypto/md5/md5.go?name=release#129)

```go
func Sum(data []byte) [Size]byte
```

返回数据data的MD5校验和。

Example

```go
data := []byte("These pretzels are making me thirsty.")
fmt.Printf("%x", md5.Sum(data))
```

Output:

```go
b0804ec967f48520697662a204f5fe72
```

### func [New](https://github.com/golang/go/blob/master/src/crypto/md5/md5.go?name=release#49)

```go
func New() hash.Hash
```

返回一个新的使用MD5校验的hash.Hash接口。

Example

```go
h := md5.New()
io.WriteString(h, "The fog is getting thicker!")
io.WriteString(h, "And Leon's getting laaarger!")
fmt.Printf("%x", h.Sum(nil))
```

Output:

```go
e2c569be17396eca2a2e3c11578123ed
```

# regexp包

package regexp

```go
import "regexp"
```

regexp包实现了正则表达式搜索。

正则表达式采用RE2语法（除了\c、\C），和Perl、Python等语言的正则基本一致。

参见<http://code.google.com/p/re2/wiki/Syntax>。

### Syntax

本包采用的正则表达式语法，默认采用perl标志。某些语法可以通过切换解析时的标志来关闭。

单字符：

```go
        .              任意字符（标志s==true时还包括换行符）
        [xyz]          字符族
        [^xyz]         反向字符族
        \d             Perl预定义字符族
        \D             反向Perl预定义字符族
        [:alpha:]      ASCII字符族
        [:^alpha:]     反向ASCII字符族
        \pN            Unicode字符族（单字符名），参见unicode包
        \PN            反向Unicode字符族（单字符名）
        \p{Greek}      Unicode字符族（完整字符名）
        \P{Greek}      反向Unicode字符族（完整字符名）
```

结合：

```go
        xy             匹配x后接着匹配y
        x|y            匹配x或y（优先匹配x）
```

重复：

```go
        x*             重复>=0次匹配x，越多越好（优先重复匹配x）
        x+             重复>=1次匹配x，越多越好（优先重复匹配x）
        x?             0或1次匹配x，优先1次
        x{n,m}         n到m次匹配x，越多越好（优先重复匹配x）
        x{n,}          重复>=n次匹配x，越多越好（优先重复匹配x）
        x{n}           重复n次匹配x
        x*?            重复>=0次匹配x，越少越好（优先跳出重复）
        x+?            重复>=1次匹配x，越少越好（优先跳出重复）
        x??            0或1次匹配x，优先0次
        x{n,m}?        n到m次匹配x，越少越好（优先跳出重复）
        x{n,}?         重复>=n次匹配x，越少越好（优先跳出重复）
        x{n}?          重复n次匹配x
```

实现的限制：计数格式x{n}等（不包括x*等格式）中n最大值1000。负数或者显式出现的过大的值会导致解析错误，返回ErrInvalidRepeatSize。

分组：

```go
        (re)           编号的捕获分组
        (?P<name>re)   命名并编号的捕获分组
        (?:re)         不捕获的分组
        (?flags)       设置当前所在分组的标志，不捕获也不匹配
        (?flags:re)    设置re段的标志，不捕获的分组
```

标志的语法为xyz（设置）、-xyz（清楚）、xy-z（设置xy，清楚z），标志如下：

```go
        I              大小写敏感（默认关闭）
        m              ^和$在匹配文本开始和结尾之外，还可以匹配行首和行尾（默认开启）
        s              让.可以匹配\n（默认关闭）
        U              非贪婪的：交换x*和x*?、x+和x+?……的含义（默认关闭）
```

边界匹配：

```go
        ^              匹配文本开始，标志m为真时，还匹配行首
        $              匹配文本结尾，标志m为真时，还匹配行尾
        \A             匹配文本开始
        \b             单词边界（一边字符属于\w，另一边为文首、文尾、行首、行尾或属于\W）
        \B             非单词边界
        \z             匹配文本结尾
```

转义序列：

```go
        \a             响铃符（\007）
        \f             换纸符（\014）
        \t             水平制表符（\011）
        \n             换行符（\012）
        \r             回车符（\015）
        \v             垂直制表符（\013）
        \123           八进制表示的字符码（最多三个数字）
        \x7F           十六进制表示的字符码（必须两个数字）
        \x{10FFFF}     十六进制表示的字符码
        \*             字面值'*'
        \Q...\E        反斜线后面的字符的字面值
```

字符族（预定义字符族之外，方括号内部）的语法：

```go
        x              单个字符
        A-Z            字符范围（方括号内部才可以用）
        \d             Perl字符族
        [:foo:]        ASCII字符族
        \pF            单字符名的Unicode字符族
        \p{Foo}        完整字符名的Unicode字符族
```

预定义字符族作为字符族的元素：

```go
        [\d]           == \d
        [^\d]          == \D
        [\D]           == \D
        [^\D]          == \d
        [[:name:]]     == [:name:]
        [^[:name:]]    == [:^name:]
        [\p{Name}]     == \p{Name}
        [^\p{Name}]    == \P{Name}
```

Perl字符族：

```go
        \d             == [0-9]
        \D             == [^0-9]
        \s             == [\t\n\f\r ]
        \S             == [^\t\n\f\r ]
        \w             == [0-9A-Za-z_]
        \W             == [^0-9A-Za-z_]
```

ASCII字符族：

```go
        [:alnum:]      == [0-9A-Za-z]
        [:alpha:]      == [A-Za-z]
        [:ascii:]      == [\x00-\x7F]
        [:blank:]      == [\t ]
        [:cntrl:]      == [\x00-\x1F\x7F]
        [:digit:]      == [0-9]
        [:graph:]      == [!-~] == [A-Za-z0-9!"#$%&'()*+,\-./:;<=>?@[\\\]^_`{|}~]
        [:lower:]      == [a-z]
        [:print:]      == [ -~] == [ [:graph:]]
        [:punct:]      == [!-/:-@[-`{-~]
        [:space:]      == [\t\n\v\f\r ]
        [:upper:]      == [A-Z]
        [:word:]       == [0-9A-Za-z_]
        [:xdigit:]     == [0-9A-Fa-f]
```

本包的正则表达式保证搜索复杂度为O(n)，其中n为输入的长度。这一点很多其他开源实现是无法保证的。参见：

```go
http://swtch.com/~rsc/regexp/regexp1.html
```

或其他关于自动机理论的书籍。

所有的字符都被视为utf-8编码的码值。

Regexp类型提供了多达16个方法，用于匹配正则表达式并获取匹配的结果。它们的名字满足如下正则表达式：

```go
Find(All)?(String)?(Submatch)?(Index)?
```

如果'All'出现了，该方法会返回输入中所有互不重叠的匹配结果。如果一个匹配结果的前后（没有间隔字符）存在长度为0的成功匹配，该空匹配会被忽略。包含All的方法会要求一个额外的整数参数n，如果n>=0，方法会返回最多前n个匹配结果。

如果'String'出现了，匹配对象为字符串，否则应该是[]byte类型，返回值和匹配对象的类型是对应的。

如果'Submatch'出现了，返回值是表示正则表达式中成功的组匹配（子匹配/次级匹配）的切片。组匹配是正则表达式内部的括号包围的次级表达式（也被称为“捕获分组”），从左到右按左括号的顺序编号。，索引0的组匹配为完整表达式的匹配结果，1为第一个分组的匹配结果，依次类推。

如果'Index'出现了，匹配/分组匹配会用输入流的字节索引对表示result[2*n:2*n+1]表示第n个分组匹配的的匹配结果。如果没有'Index'，匹配结果表示为匹配到的文本。如果索引为负数，表示分组匹配没有匹配到输入流中的文本。

方法集也有一个用于从RuneReader中读取文本进行匹配的子集：

```go
MatchReader, FindReaderIndex, FindReaderSubmatchIndex
```

该子集可能会增加。注意正则表达式匹配可能需要检验匹配结果前后的文本，因此从RuneReader匹配文本的方法很可能会读取到远远超出返回的结果所在的位置。

（另有几个其他方法不满足该方法模式的）

Example

```go
// Compile the expression once, usually at init time.
// Use raw strings to avoid having to quote the backslashes.
var validID = regexp.MustCompile(`^[a-z]+\[[0-9]+\]$`)
fmt.Println(validID.MatchString("adam[23]"))
fmt.Println(validID.MatchString("eve[7]"))
fmt.Println(validID.MatchString("Job[48]"))
fmt.Println(validID.MatchString("snakey"))
```

Output:

```go
true
true
false
false
```

### func [QuoteMeta](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#581)

```go
func QuoteMeta(s string) string
```

QuoteMeta返回将s中所有正则表达式元字符都进行转义后字符串。该字符串可以用在正则表达式中匹配字面值s。例如，QuoteMeta(`[foo]`)会返回`\[foo\]`。

### func [Match](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#433)

```go
func Match(pattern string, b []byte) (matched bool, err error)
```

Match检查b中是否存在匹配pattern的子序列。更复杂的用法请使用Compile函数和Regexp对象。

### func [MatchString](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#422)

```go
func MatchString(pattern string, s string) (matched bool, err error)
```

MatchString类似Match，但匹配对象是字符串。

Example

```go
matched, err := regexp.MatchString("foo.*", "seafood")
fmt.Println(matched, err)
matched, err = regexp.MatchString("bar.*", "seafood")
fmt.Println(matched, err)
matched, err = regexp.MatchString("a(b", "seafood")
fmt.Println(matched, err)
```

Output:

```go
true <nil>
false <nil>
false error parsing regexp: missing closing ): `a(b`
```

### func [MatchReader](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#411)

```go
func MatchReader(pattern string, r io.RuneReader) (matched bool, err error)
```

MatchReader类似Match，但匹配对象是io.RuneReader。

### type [Regexp](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#82)

```go
type Regexp struct {
    // 内含隐藏或非导出字段
}
```

Regexp代表一个编译好的正则表达式。Regexp可以被多线程安全地同时使用。

#### func [Compile](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#117)

```
func Compile(expr string) (*Regexp, error)
```

Compile解析并返回一个正则表达式。如果成功返回，该Regexp就可用于匹配文本。

在匹配文本时，该正则表达式会尽可能早的开始匹配，并且在匹配过程中选择回溯搜索到的第一个匹配结果。这种模式被称为“leftmost-first”，Perl、Python和其他实现都采用了这种模式，但本包的实现没有回溯的损耗。对POSIX的“leftmost-longest”模式，参见CompilePOSIX。

#### func [CompilePOSIX](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#140)

```
func CompilePOSIX(expr string) (*Regexp, error)
```

类似Compile但会将语法约束到POSIX ERE（egrep）语法，并将匹配模式设置为leftmost-longest。

在匹配文本时，该正则表达式会尽可能早的开始匹配，并且在匹配过程中选择搜索到的最长的匹配结果。这种模式被称为“leftmost-longest”，POSIX采用了这种模式（早期正则的DFA自动机模式）。

然而，可能会有多个“leftmost-longest”匹配，每个都有不同的组匹配状态，本包在这里和POSIX不同。在所有可能的“leftmost-longest”匹配里，本包选择回溯搜索时第一个找到的，而POSIX会选择候选结果中第一个组匹配最长的（可能有多个），然后再从中选出第二个组匹配最长的，依次类推。POSIX规则计算困难，甚至没有良好定义。

参见<http://swtch.com/~rsc/regexp/regexp2.html#posix>获取细节。

#### func [MustCompile](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#218)

```
func MustCompile(str string) *Regexp
```

MustCompile类似Compile但会在解析失败时panic，主要用于全局正则表达式变量的安全初始化。

#### func [MustCompilePOSIX](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#229)

```
func MustCompilePOSIX(str string) *Regexp
```

MustCompilePOSIX类似CompilePOSIX但会在解析失败时panic，主要用于全局正则表达式变量的安全初始化。

#### func (*Regexp) [String](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#103)

```
func (re *Regexp) String() string
```

String返回用于编译成正则表达式的字符串。

#### func (*Regexp) [LiteralPrefix](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#388)

```
func (re *Regexp) LiteralPrefix() (prefix string, complete bool)
```

LiteralPrefix返回一个字符串字面值prefix，任何匹配本正则表达式的字符串都会以prefix起始。 如果该字符串字面值包含整个正则表达式，返回值complete会设为真。

#### func (*Regexp) [NumSubexp](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#245)

```
func (re *Regexp) NumSubexp() int
```

NumSubexp返回该正则表达式中捕获分组的数量。

#### func (*Regexp) [SubexpNames](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#254)

```
func (re *Regexp) SubexpNames() []string
```

SubexpNames返回该正则表达式中捕获分组的名字。第一个分组的名字是names[1]，因此，如果m是一个组匹配切片，m[i]的名字是SubexpNames()[i]。因为整个正则表达式是无法被命名的，names[0]必然是空字符串。该切片不应被修改。

Example

```
re := regexp.MustCompile("(?P<first>[a-zA-Z]+) (?P<last>[a-zA-Z]+)")
fmt.Println(re.MatchString("Alan Turing"))
fmt.Printf("%q\n", re.SubexpNames())
reversed := fmt.Sprintf("${%s} ${%s}", re.SubexpNames()[2], re.SubexpNames()[1])
fmt.Println(reversed)
fmt.Println(re.ReplaceAllString("Alan Turing", reversed))
```

Output:

```
true
["" "first" "last"]
${last} ${first}
Turing Alan
```

#### func (*Regexp) [Longest](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#148)

```
func (re *Regexp) Longest()
```

Longest让正则表达式在之后的搜索中都采用"leftmost-longest"模式。在匹配文本时，该正则表达式会尽可能早的开始匹配，并且在匹配过程中选择搜索到的最长的匹配结果。

#### func (*Regexp) [Match](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#404)

```
func (re *Regexp) Match(b []byte) bool
```

Match检查b中是否存在匹配pattern的子序列。

#### func (*Regexp) [MatchString](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#399)

```
func (re *Regexp) MatchString(s string) bool
```

MatchString类似Match，但匹配对象是字符串。

#### func (*Regexp) [MatchReader](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#394)

```
func (re *Regexp) MatchReader(r io.RuneReader) bool
```

MatchReader类似Match，但匹配对象是io.RuneReader。

#### func (*Regexp) [Find](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#663)

```
func (re *Regexp) Find(b []byte) []byte
```

Find返回保管正则表达式re在b中的最左侧的一个匹配结果的[]byte切片。如果没有匹配到，会返回nil。

#### func (*Regexp) [FindString](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#688)

```
func (re *Regexp) FindString(s string) string
```

Find返回保管正则表达式re在b中的最左侧的一个匹配结果的字符串。如果没有匹配到，会返回""；但如果正则表达式成功匹配了一个空字符串，也会返回""。如果需要区分这种情况，请使用FindStringIndex 或FindStringSubmatch。

Example

```
re := regexp.MustCompile("fo.?")
fmt.Printf("%q\n", re.FindString("seafood"))
fmt.Printf("%q\n", re.FindString("meat"))
```

Output:

```
"foo"
""
```

#### func (*Regexp) [FindIndex](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#675)

```
func (re *Regexp) FindIndex(b []byte) (loc []int)
```

Find返回保管正则表达式re在b中的最左侧的一个匹配结果的起止位置的切片（显然len(loc)==2）。匹配结果可以通过起止位置对b做切片操作得到：b[loc[0]:loc[1]]。如果没有匹配到，会返回nil。

#### func (*Regexp) [FindStringIndex](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#700)

```
func (re *Regexp) FindStringIndex(s string) (loc []int)
```

Find返回保管正则表达式re在b中的最左侧的一个匹配结果的起止位置的切片（显然len(loc)==2）。匹配结果可以通过起止位置对b做切片操作得到：b[loc[0]:loc[1]]。如果没有匹配到，会返回nil。

Example

```
re := regexp.MustCompile("ab?")
fmt.Println(re.FindStringIndex("tablett"))
fmt.Println(re.FindStringIndex("foo") == nil)
```

Output:

```
[1 3]
true
```

#### func (*Regexp) [FindReaderIndex](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#713)

```
func (re *Regexp) FindReaderIndex(r io.RuneReader) (loc []int)
```

Find返回保管正则表达式re在b中的最左侧的一个匹配结果的起止位置的切片（显然len(loc)==2）。匹配结果可以在输入流r的字节偏移量loc[0]到loc[1]-1（包括二者）位置找到。如果没有匹配到，会返回nil。

#### func (*Regexp) [FindSubmatch](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#726)

```
func (re *Regexp) FindSubmatch(b []byte) [][]byte
```

Find返回一个保管正则表达式re在b中的最左侧的一个匹配结果以及（可能有的）分组匹配的结果的[][]byte切片。如果没有匹配到，会返回nil。

#### func (*Regexp) [FindStringSubmatch](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#882)

```
func (re *Regexp) FindStringSubmatch(s string) []string
```

Find返回一个保管正则表达式re在b中的最左侧的一个匹配结果以及（可能有的）分组匹配的结果的[]string切片。如果没有匹配到，会返回nil。

Example

```
re := regexp.MustCompile("a(x*)b(y|z)c")
fmt.Printf("%q\n", re.FindStringSubmatch("-axxxbyc-"))
fmt.Printf("%q\n", re.FindStringSubmatch("-abzc-"))
```

Output:

```
["axxxbyc" "xxx" "y"]
["abzc" "" "z"]
```

#### func (*Regexp) [FindSubmatchIndex](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#873)

```
func (re *Regexp) FindSubmatchIndex(b []byte) []int
```

Find返回一个保管正则表达式re在b中的最左侧的一个匹配结果以及（可能有的）分组匹配的结果的起止位置的切片。匹配结果和分组匹配结果可以通过起止位置对b做切片操作得到：b[loc[2*n]:loc[2*n+1]]。如果没有匹配到，会返回nil。

#### func (*Regexp) [FindStringSubmatchIndex](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#901)

```
func (re *Regexp) FindStringSubmatchIndex(s string) []int
```

Find返回一个保管正则表达式re在b中的最左侧的一个匹配结果以及（可能有的）分组匹配的结果的起止位置的切片。匹配结果和分组匹配结果可以通过起止位置对b做切片操作得到：b[loc[2*n]:loc[2*n+1]]。如果没有匹配到，会返回nil。

#### func (*Regexp) [FindReaderSubmatchIndex](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#910)

```
func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int
```

Find返回一个保管正则表达式re在b中的最左侧的一个匹配结果以及（可能有的）分组匹配的结果的起止位置的切片。匹配结果和分组匹配结果可以在输入流r的字节偏移量loc[0]到loc[1]-1（包括二者）位置找到。如果没有匹配到，会返回nil。

#### func (*Regexp) [FindAll](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#920)

```
func (re *Regexp) FindAll(b []byte, n int) [][]byte
```

Find返回保管正则表达式re在b中的所有不重叠的匹配结果的[][]byte切片。如果没有匹配到，会返回nil。

#### func (*Regexp) [FindAllString](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#956)

```
func (re *Regexp) FindAllString(s string, n int) []string
```

Find返回保管正则表达式re在b中的所有不重叠的匹配结果的[]string切片。如果没有匹配到，会返回nil。

Example

```
re := regexp.MustCompile("a.")
fmt.Println(re.FindAllString("paranormal", -1))
fmt.Println(re.FindAllString("paranormal", 2))
fmt.Println(re.FindAllString("graal", -1))
fmt.Println(re.FindAllString("none", -1))
```

Output:

```
[ar an al]
[ar an]
[aa]
[]
```

#### func (*Regexp) [FindAllIndex](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#938)

```
func (re *Regexp) FindAllIndex(b []byte, n int) [][]int
```

Find返回保管正则表达式re在b中的所有不重叠的匹配结果的起止位置的切片。如果没有匹配到，会返回nil。

#### func (*Regexp) [FindAllStringIndex](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#974)

```
func (re *Regexp) FindAllStringIndex(s string, n int) [][]int
```

Find返回保管正则表达式re在b中的所有不重叠的匹配结果的起止位置的切片。如果没有匹配到，会返回nil。

#### func (*Regexp) [FindAllSubmatch](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#992)

```
func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte
```

Find返回一个保管正则表达式re在b中的所有不重叠的匹配结果及其对应的（可能有的）分组匹配的结果的[][][]byte切片。如果没有匹配到，会返回nil。

#### func (*Regexp) [FindAllStringSubmatch](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#1034)

```
func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string
```

Find返回一个保管正则表达式re在b中的所有不重叠的匹配结果及其对应的（可能有的）分组匹配的结果的[][]string切片。如果没有匹配到，会返回nil。

Example

```
re := regexp.MustCompile("a(x*)b")
fmt.Printf("%q\n", re.FindAllStringSubmatch("-ab-", -1))
fmt.Printf("%q\n", re.FindAllStringSubmatch("-axxb-", -1))
fmt.Printf("%q\n", re.FindAllStringSubmatch("-ab-axb-", -1))
fmt.Printf("%q\n", re.FindAllStringSubmatch("-axxb-ab-", -1))
```

Output:

```
[["ab" ""]]
[["axxb" "xx"]]
[["ab" ""] ["axb" "x"]]
[["axxb" "xx"] ["ab" ""]]
```

#### func (*Regexp) [FindAllSubmatchIndex](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#1016)

```
func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int
```

Find返回一个保管正则表达式re在b中的所有不重叠的匹配结果及其对应的（可能有的）分组匹配的结果的起止位置的切片（第一层表示第几个匹配结果，完整匹配和分组匹配的起止位置对在第二层）。如果没有匹配到，会返回nil。

#### func (*Regexp) [FindAllStringSubmatchIndex](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#1059)

```
func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int
```

Find返回一个保管正则表达式re在b中的所有不重叠的匹配结果及其对应的（可能有的）分组匹配的结果的起止位置的切片（第一层表示第几个匹配结果，完整匹配和分组匹配的起止位置对在第二层）。如果没有匹配到，会返回nil。

Example

```
re := regexp.MustCompile("a(x*)b")
// Indices:
//    01234567   012345678
//    -ab-axb-   -axxb-ab-
fmt.Println(re.FindAllStringSubmatchIndex("-ab-", -1))
fmt.Println(re.FindAllStringSubmatchIndex("-axxb-", -1))
fmt.Println(re.FindAllStringSubmatchIndex("-ab-axb-", -1))
fmt.Println(re.FindAllStringSubmatchIndex("-axxb-ab-", -1))
fmt.Println(re.FindAllStringSubmatchIndex("-foo-", -1))
```

Output:

```
[[1 3 2 2]]
[[1 5 2 4]]
[[1 3 2 2] [4 7 5 6]]
[[1 5 2 4] [6 8 7 7]]
[]
```

#### func (*Regexp) [Split](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#1088)

```
func (re *Regexp) Split(s string, n int) []string
```

Split将re在s中匹配到的结果作为分隔符将s分割成多个字符串，并返回这些正则匹配结果之间的字符串的切片。

返回的切片不会包含正则匹配的结果，只包含匹配结果之间的片段。当正则表达式re中不含正则元字符时，本方法等价于strings.SplitN。

举例：

```
s := regexp.MustCompile("a*").Split("abaabaccadaaae", 5)
// s: ["", "b", "b", "c", "cadaaae"]
```

参数n绝对返回的子字符串的数量：

```
n > 0 : 返回最多n个子字符串，最后一个子字符串是剩余未进行分割的部分。
n == 0: 返回nil (zero substrings)
n < 0 : 返回所有子字符串
```

#### func (*Regexp) [Expand](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#757)

```
func (re *Regexp) Expand(dst []byte, template []byte, src []byte, match []int) []byte
```

Expand返回新生成的将template添加到dst后面的切片。在添加时，Expand会将template中的变量替换为从src匹配的结果。match应该是被FindSubmatchIndex返回的匹配结果起止位置索引。（通常就是匹配src，除非你要将匹配得到的位置用于另一个[]byte）

在template参数里，一个变量表示为格式如：$name或${name}的字符串，其中name是长度>0的字母、数字和下划线的序列。一个单纯的数字字符名如$1会作为捕获分组的数字索引；其他的名字对应(?P<name>...)语法产生的命名捕获分组的名字。超出范围的数字索引、索引对应的分组未匹配到文本、正则表达式中未出现的分组名，都会被替换为空切片。

$name格式的变量名，name会尽可能取最长序列：$1x等价于${1x}而非${1}x，$10等价于${10}而非${1}0。因此$name适用在后跟空格/换行等字符的情况，${name}适用所有情况。

如果要在输出中插入一个字面值'$'，在template里可以使用$$。

#### func (*Regexp) [ExpandString](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#764)

```
func (re *Regexp) ExpandString(dst []byte, template string, src string, match []int) []byte
```

ExpandString类似Expand，但template和src参数为字符串。它将替换结果添加到切片并返回切片，以便让调用代码控制内存申请。

#### func (*Regexp) [ReplaceAllLiteral](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#556)

```
func (re *Regexp) ReplaceAllLiteral(src, repl []byte) []byte
```

ReplaceAllLiteral返回src的一个拷贝，将src中所有re的匹配结果都替换为repl。repl参数被直接使用，不会使用Expand进行扩展。

#### func (*Regexp) [ReplaceAllLiteralString](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#458)

```
func (re *Regexp) ReplaceAllLiteralString(src, repl string) string
```

ReplaceAllLiteralString返回src的一个拷贝，将src中所有re的匹配结果都替换为repl。repl参数被直接使用，不会使用Expand进行扩展。

Example

```
re := regexp.MustCompile("a(x*)b")
fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "T"))
fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "$1"))
fmt.Println(re.ReplaceAllLiteralString("-ab-axxb-", "${1}"))
```

Output:

```
-T-T-
-$1-$1-
-${1}-${1}-
```

#### func (*Regexp) [ReplaceAll](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#538)

```
func (re *Regexp) ReplaceAll(src, repl []byte) []byte
```

ReplaceAllLiteral返回src的一个拷贝，将src中所有re的匹配结果都替换为repl。在替换时，repl中的'$'符号会按照Expand方法的规则进行解释和替换，例如$1会被替换为第一个分组匹配结果。

#### func (*Regexp) [ReplaceAllString](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#444)

```
func (re *Regexp) ReplaceAllString(src, repl string) string
```

ReplaceAllLiteral返回src的一个拷贝，将src中所有re的匹配结果都替换为repl。在替换时，repl中的'$'符号会按照Expand方法的规则进行解释和替换，例如$1会被替换为第一个分组匹配结果。

Example

```
re := regexp.MustCompile("a(x*)b")
fmt.Println(re.ReplaceAllString("-ab-axxb-", "T"))
fmt.Println(re.ReplaceAllString("-ab-axxb-", "$1"))
fmt.Println(re.ReplaceAllString("-ab-axxb-", "$1W"))
fmt.Println(re.ReplaceAllString("-ab-axxb-", "${1}W"))
```

Output:

```
-T-T-
--xx-
---
-W-xxW-
```

#### func (*Regexp) [ReplaceAllFunc](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#566)

```
func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte
```

ReplaceAllLiteral返回src的一个拷贝，将src中所有re的匹配结果（设为matched）都替换为repl(matched)。repl返回的切片被直接使用，不会使用Expand进行扩展。

#### func (*Regexp) [ReplaceAllStringFunc](https://github.com/golang/go/blob/master/src/regexp/regexp.go?name=release#468)

```
func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string
```

ReplaceAllLiteral返回src的一个拷贝，将src中所有re的匹配结果（设为matched）都替换为repl(matched)。repl返回的字符串被直接使用，不会使用Expand进行扩展。

# errors包

package errors

```go
import "errors"
```

errors包实现了创建错误值的函数。

Example

```go
package errors_test
import (
    "fmt"
    "time"
)
// MyError is an error implementation that includes a time and message.
type MyError struct {
    When time.Time
    What string
}
func (e MyError) Error() string {
    return fmt.Sprintf("%v: %v", e.When, e.What)
}
func oops() error {
    return MyError{
        time.Date(1989, 3, 15, 22, 30, 0, 0, time.UTC),
        "the file system has gone away",
    }
}
func Example() {
    if err := oops(); err != nil {
        fmt.Println(err)
    }
    // Output: 1989-03-15 22:30:00 +0000 UTC: the file system has gone away
}
```

### func [New](https://github.com/golang/go/blob/master/src/errors/errors.go?name=release#9)

```go
func New(text string) error
```

使用字符串创建一个错误,请类比fmt包的Errorf方法，差不多可以认为是New(fmt.Sprintf(...))。

Example

```go
err := errors.New("emit macho dwarf: elf header corrupted")
if err != nil {
    fmt.Print(err)
}
```

Output:

```go
emit macho dwarf: elf header corrupted
```

Example (Errorf)

```go
const name, id = "bimmler", 17
err := fmt.Errorf("user %q (id %d) not found", name, id)
if err != nil {
    fmt.Print(err)
}
```

Output:

```go
user "bimmler" (id 17) not found
```

# crypto/rand包

## package rand

```
import "crypto/rand"
```

rand包实现了用于加解密的更安全的随机数生成器。

### Variables

```go
var Reader io.Reader
```

Reader是一个全局、共享的密码用强随机数生成器。在Unix类型系统中，会从/dev/urandom读取；而Windows中会调用CryptGenRandom API。

### func [Int](https://github.com/golang/go/blob/master/src/crypto/rand/util.go?name=release#106)

```go
func Int(rand io.Reader, max *big.Int) (n *big.Int, err error)
```

返回一个在[0, max)区间服从均匀分布的随机值，如果max<=0则会panic。

### func [Prime](https://github.com/golang/go/blob/master/src/crypto/rand/util.go?name=release#31)

```go
func Prime(rand io.Reader, bits int) (p *big.Int, err error)
```

返回一个具有指定字位数的数字，该数字具有很高可能性是质数。如果从rand读取时出错，或者bits<2会返回错误。

### func [Read](https://github.com/golang/go/blob/master/src/crypto/rand/rand.go?name=release#19)

```go
func Read(b []byte) (n int, err error)
```

本函数是一个使用io.ReadFull调用Reader.Read的辅助性函数。当且仅当err == nil时，返回值n == len(b)。

Example

```go
c := 10
b := make([]byte, c)
_, err := rand.Read(b)
if err != nil {
    fmt.Println("error:", err)
    return
}
// The slice should now contain random bytes instead of only zeroes.
fmt.Println(bytes.Equal(b, make([]byte, c)))
```

Output:

```go
false
```

# math/rand包

package rand

```go
import "math/rand"
```

rand包实现了伪随机数生成器。

随机数从资源生成。包水平的函数都使用的默认的公共资源。该资源会在程序每次运行时都产生确定的序列。如果需要每次运行产生不同的序列，应使用Seed函数进行初始化。默认资源可以安全的用于多go程并发。

Example

```go
rand.Seed(42) // Try changing this number!
answers := []string{
    "It is certain",
    "It is decidedly so",
    "Without a doubt",
    "Yes definitely",
    "You may rely on it",
    "As I see it yes",
    "Most likely",
    "Outlook good",
    "Yes",
    "Signs point to yes",
    "Reply hazy try again",
    "Ask again later",
    "Better not tell you now",
    "Cannot predict now",
    "Concentrate and ask again",
    "Don't count on it",
    "My reply is no",
    "My sources say no",
    "Outlook not so good",
    "Very doubtful",
}
fmt.Println("Magic 8-Ball says:", answers[rand.Intn(len(answers))])
```

Output:

```go
Magic 8-Ball says: As I see it yes
```

Example (Rand)

```go
// Create and seed the generator.
// Typically a non-fixed seed should be used, such as time.Now().UnixNano().
// Using a fixed seed will produce the same output on every run.
r := rand.New(rand.NewSource(99))
// The tabwriter here helps us generate aligned output.
w := tabwriter.NewWriter(os.Stdout, 1, 1, 1, ' ', 0)
defer w.Flush()
show := func(name string, v1, v2, v3 interface{}) {
    fmt.Fprintf(w, "%s\t%v\t%v\t%v\n", name, v1, v2, v3)
}
// Float32 and Float64 values are in [0, 1).
show("Float32", r.Float32(), r.Float32(), r.Float32())
show("Float64", r.Float64(), r.Float64(), r.Float64())
// ExpFloat64 values have an average of 1 but decay exponentially.
show("ExpFloat64", r.ExpFloat64(), r.ExpFloat64(), r.ExpFloat64())
// NormFloat64 values have an average of 0 and a standard deviation of 1.
show("NormFloat64", r.NormFloat64(), r.NormFloat64(), r.NormFloat64())
// Int31, Int63, and Uint32 generate values of the given width.
// The Int method (not shown) is like either Int31 or Int63
// depending on the size of 'int'.
show("Int31", r.Int31(), r.Int31(), r.Int31())
show("Int63", r.Int63(), r.Int63(), r.Int63())
show("Uint32", r.Int63(), r.Int63(), r.Int63())
// Intn, Int31n, and Int63n limit their output to be < n.
// They do so more carefully than using r.Int()%n.
show("Intn(10)", r.Intn(10), r.Intn(10), r.Intn(10))
show("Int31n(10)", r.Int31n(10), r.Int31n(10), r.Int31n(10))
show("Int63n(10)", r.Int63n(10), r.Int63n(10), r.Int63n(10))
// Perm generates a random permutation of the numbers [0, n).
show("Perm", r.Perm(5), r.Perm(5), r.Perm(5))
```

Output:

```go
Float32     0.2635776           0.6358173           0.6718283
Float64     0.628605430454327   0.4504798828572669  0.9562755949377957
ExpFloat64  0.3362240648200941  1.4256072328483647  0.24354758816173044
NormFloat64 0.17233959114940064 1.577014951434847   0.04259129641113857
Int31       1501292890          1486668269          182840835
Int63       3546343826724305832 5724354148158589552 5239846799706671610
Uint32      5927547564735367388 637072299495207830  4128311955958246186
Intn(10)    1                   2                   5
Int31n(10)  4                   7                   8
Int63n(10)  7                   6                   3
Perm        [1 4 2 3 0]         [4 2 1 3 0]         [1 2 4 0 3]
```

### type [Source](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#18)

```go
type Source interface {
    Int63() int64
    Seed(seed int64)
}
```

Source代表一个生成均匀分布在范围[0, 1<<63)的int64值的（伪随机的）资源。

#### func [NewSource](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#24)

```go
func NewSource(seed int64) Source
```

使用给定的种子创建一个伪随机资源。

### type [Rand](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#31)

```go
type Rand struct {
    // 内含隐藏或非导出字段
}
```

Rand生成服从多种分布的随机数。

#### func [New](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#37)

```go
func New(src Source) *Rand
```

返回一个使用src生产的随机数来生成其他各种分布的随机数值的*Rand。

#### func (*Rand) [Seed](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#40)

```go
func (r *Rand) Seed(seed int64)
```

使用给定的seed来初始化生成器到一个确定的状态。

#### func (*Rand) [Int](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#52)

```go
func (r *Rand) Int() int
```

返回一个非负的伪随机int值。

#### func (*Rand) [Int31](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#49)

```go
func (r *Rand) Int31() int32
```

返回一个int32类型的非负的31位伪随机数。

#### func (*Rand) [Int63](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#43)

```go
func (r *Rand) Int63() int64
```

返回一个int64类型的非负的63位伪随机数。

#### func (*Rand) [Uint32](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#46)

```go
func (r *Rand) Uint32() uint32
```

返回一个uint32类型的非负的32位伪随机数。

#### func (*Rand) [Intn](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#93)

```go
func (r *Rand) Intn(n int) int
```

返回一个取值范围在[0,n)的伪随机int值，如果n<=0会panic。

#### func (*Rand) [Int31n](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#76)

```go
func (r *Rand) Int31n(n int32) int32
```

返回一个取值范围在[0,n)的伪随机int32值，如果n<=0会panic

#### func (*Rand) [Int63n](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#59)

```go
func (r *Rand) Int63n(n int64) int64
```

返回一个取值范围在[0,n)的伪随机int64值，如果n<=0会panic。

#### func (*Rand) [Float32](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#131)

```go
func (r *Rand) Float32() float32
```

返回一个取值范围在[0.0, 1.0)的伪随机float32值。

#### func (*Rand) [Float64](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#104)

```go
func (r *Rand) Float64() float64
```

返回一个取值范围在[0.0, 1.0)的伪随机float64值。

#### func (*Rand) [NormFloat64](https://github.com/golang/go/blob/master/src/math/rand/normal.go?name=release#38)

```go
func (r *Rand) NormFloat64() float64
```

返回一个服从标准正态分布（标准差=1，期望=0）、取值范围在[-math.MaxFloat64, +math.MaxFloat64]的float64值

如果要生成不同的正态分布值，调用者可用如下代码调整输出：

```go
sample = NormFloat64() * 标准差 + 期望
```

#### func (*Rand) [ExpFloat64](https://github.com/golang/go/blob/master/src/math/rand/exp.go?name=release#31)

```go
func (r *Rand) ExpFloat64() float64
```

返回一个服从标准指数分布（率参数=1，率参数是期望的倒数）、取值范围在(0, +math.MaxFloat64]的float64值

如要生成不同的指数分布值，调用者可用如下代码调整输出：

```go
sample = ExpFloat64() / 率参数
```

#### func (*Rand) [Perm](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#146)

```go
func (r *Rand) Perm(n int) []int
```

返回一个有n个元素的，[0,n)范围内整数的伪随机排列的切片。

### type [Zipf](https://github.com/golang/go/blob/master/src/math/rand/zipf.go?name=release#15)

```go
type Zipf struct {
    // 内含隐藏或非导出字段
}
```

Zipf生成服从齐普夫分布的随机数。

#### func [NewZipf](https://github.com/golang/go/blob/master/src/math/rand/zipf.go?name=release#37)

```go
func NewZipf(r *Rand, s float64, v float64, imax uint64) *Zipf
```

NewZipf返回一个[0, imax]范围内的齐普夫随机数生成器。

齐普夫分布：值k出现的几率p(k)正比于(v+k)**(-s)，其中s>1且k>=0且v>=1。

#### func (*Zipf) [Uint64](https://github.com/golang/go/blob/master/src/math/rand/zipf.go?name=release#56)

```go
func (z *Zipf) Uint64() uint64
```

Uint64返回一个服从Zipf对象描述的齐普夫分布的随机数。

### func [Seed](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#165)

```go
func Seed(seed int64)
```

使用给定的seed将默认资源初始化到一个确定的状态；如未调用Seed，默认资源的行为就好像调用了Seed(1)。

### func [Int](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#180)

```go
func Int() int
```

返回一个非负的伪随机int值。

### func [Int31](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#177)

```go
func Int31() int32
```

返回一个int32类型的非负的31位伪随机数。

### func [Int63](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#169)

```go
func Int63() int64
```

返回一个int64类型的非负的63位伪随机数。

### func [Uint32](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#173)

```go
func Uint32() uint32
```

返回一个uint32类型的非负的32位伪随机数。

### func [Intn](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#195)

```go
func Intn(n int) int
```

返回一个取值范围在[0,n)的伪随机int值，如果n<=0会panic。

### func [Int31n](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#190)

```go
func Int31n(n int32) int32
```

返回一个取值范围在[0,n)的伪随机int32值，如果n<=0会panic。

### func [Int63n](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#185)

```go
func Int63n(n int64) int64
```

返回一个取值范围在[0, n)的伪随机int64值，如果n<=0会panic。

### func [Float32](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#203)

```go
func Float32() float32
```

返回一个取值范围在[0.0, 1.0)的伪随机float32值。

### func [Float64](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#199)

```go
func Float64() float64
```

返回一个取值范围在[0.0, 1.0)的伪随机float64值。

### func [NormFloat64](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#218)

```go
func NormFloat64() float64
```

返回一个服从标准正态分布（标准差=1，期望=0）、取值范围在[-math.MaxFloat64, +math.MaxFloat64]的float64值

如果要生成不同的正态分布值，调用者可用如下代码调整输出：

```go
sample = NormFloat64() * 标准差 + 期望
```

### func [ExpFloat64](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#228)

```go
func ExpFloat64() float64
```

返回一个服从标准指数分布（率参数=1，率参数是期望的倒数）、取值范围在(0, +math.MaxFloat64]的float64值

如要生成不同的指数分布值，调用者可用如下代码调整输出：

```
sample = ExpFloat64() / 率参数
```

### func [Perm](https://github.com/golang/go/blob/master/src/math/rand/rand.go?name=release#207)

```go
func Perm(n int) []int
```

返回一个有n个元素的，[0,n)范围内整数的伪随机排列的切片。

